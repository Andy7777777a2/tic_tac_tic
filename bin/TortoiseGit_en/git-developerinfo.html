<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>File formats, protocols and other developer interfaces</title><link rel="stylesheet" href="styles_html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="TortoiseGit"><link rel="up" href="apg.html" title="Appendix G. Git Official Documentation"><link rel="prev" href="git-misc.html#gitworkflows(7)__patch_workflow" title="Patch workflow"><link rel="next" href="git-developerinfo.html#gitformat-commit-graph(5)__chunk_lookup" title="CHUNK LOOKUP:"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">File formats, protocols and other developer interfaces</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="git-misc.html#gitworkflows(7)__patch_workflow">Prev</a> </td><th width="60%" align="center">Appendix G. Git Official Documentation</th><td width="20%" align="right"> <a accesskey="n" href="git-developerinfo.html#gitformat-commit-graph(5)__chunk_lookup">Next</a></td></tr></table><hr></div><div class="sect1" title="File formats, protocols and other developer interfaces"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="git-developerinfo"></a>File formats, protocols and other developer interfaces</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
		This Git documentation is based on Git 2.50.1.
		The up to date Git reference can be found on <a class="ulink" href="https://git-scm.com/docs/" target="_blank"><em class="citetitle">https://git-scm.com/docs/</em></a>
	</p></div><div lang="en" class="sect2" title="gitformat-bundle(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-bundle(5)"></a>gitformat-bundle(5)</h3></div></div></div><a class="indexterm" name="id1542986"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-bundle(5)__name"></a>NAME</h4></div></div></div><p>gitformat-bundle - The bundle file format</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-bundle(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>*.bundle<br>
*.bdl</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-bundle(5)__description"></a>DESCRIPTION</h4></div></div></div><p>The Git bundle format is a format that represents both refs and Git
objects. A bundle is a header in a format similar to
<a class="xref" href="git-command.html#git-show-ref(1)" title="git-show-ref(1)">the section called “git-show-ref(1)”</a> followed by a pack in *.pack format.</p><p>The format is created and read by the <a class="xref" href="git-command.html#git-bundle(1)" title="git-bundle(1)">the section called “git-bundle(1)”</a> command,
and supported by e.g. <a class="xref" href="git-command.html#git-fetch(1)" title="git-fetch(1)">the section called “git-fetch(1)”</a> and <a class="xref" href="git-command.html#git-clone(1)" title="git-clone(1)">the section called “git-clone(1)”</a>.</p></div><div class="simplesect" title="FORMAT"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-bundle(5)__format"></a>FORMAT</h4></div></div></div><p>We will use ABNF notation to define the Git bundle format. See
<a class="xref" href="git-developerinfo.html#gitprotocol-common(5)" title="gitprotocol-common(5)">the section called “gitprotocol-common(5)”</a> for the details.</p><p>A v2 bundle looks like this:</p><pre class="screen">bundle    = signature *prerequisite *reference LF pack
signature = "# v2 git bundle" LF

prerequisite = "-" obj-id SP comment LF
comment      = *CHAR
reference    = obj-id SP refname LF

pack         = ... ; packfile</pre><p>A v3 bundle looks like this:</p><pre class="screen">bundle    = signature *capability *prerequisite *reference LF pack
signature = "# v3 git bundle" LF

capability   = "@" key ["=" value] LF
prerequisite = "-" obj-id SP comment LF
comment      = *CHAR
reference    = obj-id SP refname LF
key          = 1*(ALPHA / DIGIT / "-")
value        = *(%01-09 / %0b-FF)

pack         = ... ; packfile</pre></div><div class="simplesect" title="SEMANTICS"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-bundle(5)__semantics"></a>SEMANTICS</h4></div></div></div><p>A Git bundle consists of several parts.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
"Capabilities", which are only in the v3 format, indicate functionality that
        the bundle requires to be read properly.
</li><li class="listitem">
"Prerequisites" list the objects that are NOT included in the bundle and the
  reader of the bundle MUST already have, in order to use the data in the
  bundle. The objects stored in the bundle may refer to prerequisite objects and
  anything reachable from them (e.g. a tree object in the bundle can reference
  a blob that is reachable from a prerequisite) and/or expressed as a delta
  against prerequisite objects.
</li><li class="listitem">
"References" record the tips of the history graph, iow, what the reader of the
  bundle CAN "git fetch" from it.
</li><li class="listitem">
"Pack" is the pack data stream "git fetch" would send, if you fetch from a
  repository that has the references recorded in the "References" above into a
  repository that has references pointing at the objects listed in
  "Prerequisites" above.
</li></ul></div><p>In the bundle format, there can be a comment following a prerequisite obj-id.
This is a comment and it has no specific meaning. The writer of the bundle MAY
put any string here. The reader of the bundle MUST ignore the comment.</p><div class="section" title="Note on shallow clones and Git bundles"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-bundle(5)__note_on_shallow_clones_and_git_bundles"></a>Note on shallow clones and Git bundles</h2></div></div></div><p>Note that the prerequisites do not represent a shallow-clone boundary. The
semantics of the prerequisites and the shallow-clone boundaries are different,
and the Git bundle v2 format cannot represent a shallow clone repository.</p></div></div><div class="simplesect" title="CAPABILITIES"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-bundle(5)__capabilities"></a>CAPABILITIES</h4></div></div></div><p>Because there is no opportunity for negotiation, unknown capabilities cause <span class="emphasis"><em>git
bundle</em></span> to abort.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<span class="emphasis"><em>object-format</em></span> specifies the hash algorithm in use, and can take the same
  values as the <span class="emphasis"><em>extensions.objectFormat</em></span> configuration value.
</li><li class="listitem">
<span class="emphasis"><em>filter</em></span> specifies an object filter as in the <span class="emphasis"><em>--filter</em></span> option in
  <a class="xref" href="git-command.html#git-rev-list(1)" title="git-rev-list(1)">the section called “git-rev-list(1)”</a>. The resulting pack-file must be marked as a
  <span class="emphasis"><em>.promisor</em></span> pack-file after it is unbundled.
</li></ul></div></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-bundle(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitformat-chunk(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-chunk(5)"></a>gitformat-chunk(5)</h3></div></div></div><a class="indexterm" name="id1543216"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-chunk(5)__name"></a>NAME</h4></div></div></div><p>gitformat-chunk - Chunk-based file formats</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-chunk(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><p>Used by <a class="xref" href="git-developerinfo.html#gitformat-commit-graph(5)" title="gitformat-commit-graph(5)">the section called “gitformat-commit-graph(5)”</a> and the "MIDX" format (see
the pack format documentation in <a class="xref" href="git-developerinfo.html#gitformat-pack(5)" title="gitformat-pack(5)">the section called “gitformat-pack(5)”</a>).</p></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-chunk(5)__description"></a>DESCRIPTION</h4></div></div></div><p>Some file formats in Git use a common concept of "chunks" to describe
sections of the file. This allows structured access to a large file by
scanning a small "table of contents" for the remaining data. This common
format is used by the <span class="emphasis"><em>commit-graph</em></span> and <span class="emphasis"><em>multi-pack-index</em></span> files. See
the <span class="emphasis"><em>multi-pack-index</em></span> format in <a class="xref" href="git-developerinfo.html#gitformat-pack(5)" title="gitformat-pack(5)">the section called “gitformat-pack(5)”</a> and
the <span class="emphasis"><em>commit-graph</em></span> format in <a class="xref" href="git-developerinfo.html#gitformat-commit-graph(5)" title="gitformat-commit-graph(5)">the section called “gitformat-commit-graph(5)”</a> for
how they use the chunks to describe structured data.</p><p>A chunk-based file format begins with some header information custom to
that format. That header should include enough information to identify
the file type, format version, and number of chunks in the file. From this
information, that file can determine the start of the chunk-based region.</p><p>The chunk-based region starts with a table of contents describing where
each chunk starts and ends. This consists of (C+1) rows of 12 bytes each,
where C is the number of chunks. Consider the following table:</p><pre class="literallayout">| Chunk ID (4 bytes) | Chunk Offset (8 bytes) |
|--------------------|------------------------|
| ID[0]              | OFFSET[0]              |
| ...                | ...                    |
| ID[C]              | OFFSET[C]              |
| 0x0000             | OFFSET[C+1]            |</pre><p>Each row consists of a 4-byte chunk identifier (ID) and an 8-byte offset.
Each integer is stored in network-byte order.</p><p>The chunk identifier <span class="emphasis"><em>ID[i]</em></span> is a label for the data stored within this
file from <span class="emphasis"><em>OFFSET[i]</em></span> (inclusive) to <span class="emphasis"><em>OFFSET[i+1]</em></span> (exclusive). Thus, the
size of the <span class="emphasis"><em>i`th chunk is equal to the difference between `OFFSET[i+1]</em></span>
and <span class="emphasis"><em>OFFSET[i]</em></span>. This requires that the chunk data appears contiguously
in the same order as the table of contents.</p><p>The final entry in the table of contents must be four zero bytes. This
confirms that the table of contents is ending and provides the offset for
the end of the chunk-based data.</p><p>Note: The chunk-based format expects that the file contains <span class="emphasis"><em>at least</em></span> a
trailing hash after <span class="emphasis"><em>OFFSET[C+1]</em></span>.</p><p>Functions for working with chunk-based file formats are declared in
<span class="emphasis"><em>chunk-format.h</em></span>. Using these methods provide extra checks that assist
developers when creating new file formats.</p></div><div class="simplesect" title="Writing chunk-based file formats"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-chunk(5)__writing_chunk_based_file_formats"></a>Writing chunk-based file formats</h4></div></div></div><p>To write a chunk-based file format, create a <span class="emphasis"><em>struct chunkfile</em></span> by
calling <span class="emphasis"><em>init_chunkfile()</em></span> and pass a <span class="emphasis"><em>struct hashfile</em></span> pointer. The
caller is responsible for opening the <span class="emphasis"><em>hashfile</em></span> and writing header
information so the file format is identifiable before the chunk-based
format begins.</p><p>Then, call <span class="emphasis"><em>add_chunk()</em></span> for each chunk that is intended for writing. This
populates the <span class="emphasis"><em>chunkfile</em></span> with information about the order and size of
each chunk to write. Provide a <span class="emphasis"><em>chunk_write_fn</em></span> function pointer to
perform the write of the chunk data upon request.</p><p>Call <span class="emphasis"><em>write_chunkfile()</em></span> to write the table of contents to the <span class="emphasis"><em>hashfile</em></span>
followed by each of the chunks. This will verify that each chunk wrote
the expected amount of data so the table of contents is correct.</p><p>Finally, call <span class="emphasis"><em>free_chunkfile()</em></span> to clear the <span class="emphasis"><em>struct chunkfile</em></span> data. The
caller is responsible for finalizing the <span class="emphasis"><em>hashfile</em></span> by writing the trailing
hash and closing the file.</p></div><div class="simplesect" title="Reading chunk-based file formats"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-chunk(5)__reading_chunk_based_file_formats"></a>Reading chunk-based file formats</h4></div></div></div><p>To read a chunk-based file format, the file must be opened as a
memory-mapped region. The chunk-format API expects that the entire file
is mapped as a contiguous memory region.</p><p>Initialize a <span class="emphasis"><em>struct chunkfile</em></span> pointer with <span class="emphasis"><em>init_chunkfile(NULL)</em></span>.</p><p>After reading the header information from the beginning of the file,
including the chunk count, call <span class="emphasis"><em>read_table_of_contents()</em></span> to populate
the <span class="emphasis"><em>struct chunkfile</em></span> with the list of chunks, their offsets, and their
sizes.</p><p>Extract the data information for each chunk using <span class="emphasis"><em>pair_chunk()</em></span> or
<span class="emphasis"><em>read_chunk()</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<span class="emphasis"><em>pair_chunk()</em></span> assigns a given pointer with the location inside the
  memory-mapped file corresponding to that chunk's offset. If the chunk
  does not exist, then the pointer is not modified.
</li><li class="listitem">
<span class="emphasis"><em>read_chunk()</em></span> takes a <span class="emphasis"><em>chunk_read_fn</em></span> function pointer and calls it
  with the appropriate initial pointer and size information. The function
  is not called if the chunk does not exist. Use this method to read chunks
  if you need to perform immediate parsing or if you need to execute logic
  based on the size of the chunk.
</li></ul></div><p>After calling these methods, call <span class="emphasis"><em>free_chunkfile()</em></span> to clear the
<span class="emphasis"><em>struct chunkfile</em></span> data. This will not close the memory-mapped region.
Callers are expected to own that data for the timeframe the pointers into
the region are needed.</p></div><div class="simplesect" title="Examples"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-chunk(5)__examples"></a>Examples</h4></div></div></div><p>These file formats use the chunk-format API, and can be used as examples
for future formats:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<span class="strong"><strong>commit-graph:</strong></span> see <span class="emphasis"><em>write_commit_graph_file()</em></span> and <span class="emphasis"><em>parse_commit_graph()</em></span>
  in <span class="emphasis"><em>commit-graph.c</em></span> for how the chunk-format API is used to write and
  parse the commit-graph file format documented in
  the commit-graph file format in <a class="xref" href="git-developerinfo.html#gitformat-commit-graph(5)" title="gitformat-commit-graph(5)">the section called “gitformat-commit-graph(5)”</a>.
</li><li class="listitem">
<span class="strong"><strong>multi-pack-index:</strong></span> see <span class="emphasis"><em>write_midx_internal()</em></span> and <span class="emphasis"><em>load_multi_pack_index()</em></span>
  in <span class="emphasis"><em>midx.c</em></span> for how the chunk-format API is used to write and
  parse the multi-pack-index file format documented in
  the multi-pack-index file format section of <a class="xref" href="git-developerinfo.html#gitformat-pack(5)" title="gitformat-pack(5)">the section called “gitformat-pack(5)”</a>.
</li></ul></div></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-chunk(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitformat-commit-graph(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)"></a>gitformat-commit-graph(5)</h3></div></div></div><a class="indexterm" name="id1543633"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-commit-graph(5)__name"></a>NAME</h4></div></div></div><p>gitformat-commit-graph - Git commit-graph format</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-commit-graph(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>$GIT_DIR/objects/info/commit-graph<br>
$GIT_DIR/objects/info/commit-graphs/*</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-commit-graph(5)__description"></a>DESCRIPTION</h4></div></div></div><p>The Git commit-graph stores a list of commit OIDs and some associated
metadata, including:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The generation number of the commit.
</li><li class="listitem">
The root tree OID.
</li><li class="listitem">
The commit date.
</li><li class="listitem">
The parents of the commit, stored using positional references within
  the graph file.
</li><li class="listitem">
The Bloom filter of the commit carrying the paths that were changed between
  the commit and its first parent, if requested.
</li></ul></div><p>These positional references are stored as unsigned 32-bit integers
corresponding to the array position within the list of commit OIDs. Due
to some special constants we use to track parents, we can store at most
(1 &lt;&lt; 30) + (1 &lt;&lt; 29) + (1 &lt;&lt; 28) - 1 (around 1.8 billion) commits.</p></div><div class="simplesect" title="Commit-graph files have the following format:"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-commit-graph(5)__commit_graph_files_have_the_following_format"></a>Commit-graph files have the following format:</h4></div></div></div><p>In order to allow extensions that add extra data to the graph, we organize
the body into "chunks" and provide a binary lookup table at the beginning
of the body. The header includes certain values, such as number of chunks
and hash type.</p><p>All multi-byte numbers are in network byte order.</p><div class="section" title="HEADER:"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-commit-graph(5)__header"></a>HEADER:</h2></div></div></div><pre class="literallayout">4-byte signature:
    The signature is: {'C', 'G', 'P', 'H'}</pre><pre class="literallayout">1-byte version number:
    Currently, the only valid version is 1.</pre><pre class="literallayout">1-byte Hash Version
    We infer the hash length (H) from this value:
      1 =&gt; SHA-1
      2 =&gt; SHA-256
    If the hash type does not match the repository's hash algorithm, the
    commit-graph file should be ignored with a warning presented to the
    user.</pre><pre class="literallayout">1-byte number (C) of "chunks"</pre><pre class="literallayout">1-byte number (B) of base commit-graphs
    We infer the length (H*B) of the Base Graphs chunk
    from this value.</pre></div><div class="section" title="CHUNK LOOKUP:"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-commit-graph(5)__chunk_lookup"></a>CHUNK LOOKUP:</h2></div></div></div><pre class="literallayout">(C + 1) * 12 bytes listing the table of contents for the chunks:
    First 4 bytes describe the chunk id. Value 0 is a terminating label.
    Other 8 bytes provide the byte-offset in current file for chunk to
    start. (Chunks are ordered contiguously in the file, so you can infer
    the length using the next chunk position if necessary.) Each chunk
    ID appears at most once.</pre><pre class="literallayout">The CHUNK LOOKUP matches the table of contents from
the chunk-based file format, see linkgit:gitformat-chunk[5]</pre><pre class="literallayout">The remaining data in the body is described one chunk at a time, and
these chunks may be given in any order. Chunks are required unless
otherwise specified.</pre></div><div class="section" title="CHUNK DATA:"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-commit-graph(5)__chunk_data"></a>CHUNK DATA:</h2></div></div></div><div class="section" title="OID Fanout (ID: {O, I, D, F}) (256 * 4 bytes)"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)__oid_fanout_id_emphasis_o_emphasis_emphasis_i_emphasis_emphasis_d_emphasis_emphasis_f_emphasis_256_4_bytes"></a>OID Fanout (ID: {<span class="emphasis"><em>O</em></span>, <span class="emphasis"><em>I</em></span>, <span class="emphasis"><em>D</em></span>, <span class="emphasis"><em>F</em></span>}) (256 * 4 bytes)</h3></div></div></div><pre class="literallayout">The ith entry, F[i], stores the number of OIDs with first
byte at most i. Thus F[255] stores the total
number of commits (N).</pre></div><div class="section" title="OID Lookup (ID: {O, I, D, L}) (N * H bytes)"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)__oid_lookup_id_emphasis_o_emphasis_emphasis_i_emphasis_emphasis_d_emphasis_emphasis_l_emphasis_n_h_bytes"></a>OID Lookup (ID: {<span class="emphasis"><em>O</em></span>, <span class="emphasis"><em>I</em></span>, <span class="emphasis"><em>D</em></span>, <span class="emphasis"><em>L</em></span>}) (N * H bytes)</h3></div></div></div><pre class="literallayout">The OIDs for all commits in the graph, sorted in ascending order.</pre></div><div class="section" title="Commit Data (ID: {C, D, A, T }) (N * (H + 16) bytes)"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)__commit_data_id_emphasis_c_emphasis_emphasis_d_emphasis_emphasis_a_emphasis_emphasis_t_emphasis_n_h_16_bytes"></a>Commit Data (ID: {<span class="emphasis"><em>C</em></span>, <span class="emphasis"><em>D</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>T</em></span> }) (N * (H + 16) bytes)</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The first H bytes are for the OID of the root tree.
</li><li class="listitem">
The next 8 bytes are for the positions of the first two parents
      of the ith commit. Stores value 0x70000000 if no parent in that
      position. If there are more than two parents, the second value
      has its most-significant bit on and the other bits store an array
      position into the Extra Edge List chunk.
</li><li class="listitem">
The next 8 bytes store the topological level (generation number v1)
      of the commit and
      the commit time in seconds since EPOCH. The generation number
      uses the higher 30 bits of the first 4 bytes, while the commit
      time uses the 32 bits of the second 4 bytes, along with the lowest
      2 bits of the lowest byte, storing the 33rd and 34th bit of the
      commit time.
</li></ul></div></div><div class="section" title="Generation Data (ID: {G, D, A, 2 }) (N * 4 bytes) [Optional]"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)__generation_data_id_emphasis_g_emphasis_emphasis_d_emphasis_emphasis_a_emphasis_emphasis_2_emphasis_n_4_bytes_optional"></a>Generation Data (ID: {<span class="emphasis"><em>G</em></span>, <span class="emphasis"><em>D</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>2</em></span> }) (N * 4 bytes) [Optional]</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
This list of 4-byte values store corrected commit date offsets for the
      commits, arranged in the same order as commit data chunk.
</li><li class="listitem">
If the corrected commit date offset cannot be stored within 31 bits,
      the value has its most-significant bit on and the other bits store
      the position of corrected commit date into the Generation Data Overflow
      chunk.
</li><li class="listitem">
Generation Data chunk is present only when commit-graph file is written
      by compatible versions of Git and in case of split commit-graph chains,
      the topmost layer also has Generation Data chunk.
</li></ul></div></div><div class="section" title="Generation Data Overflow (ID: {G, D, O, 2 }) [Optional]"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)__generation_data_overflow_id_emphasis_g_emphasis_emphasis_d_emphasis_emphasis_o_emphasis_emphasis_2_emphasis_optional"></a>Generation Data Overflow (ID: {<span class="emphasis"><em>G</em></span>, <span class="emphasis"><em>D</em></span>, <span class="emphasis"><em>O</em></span>, <span class="emphasis"><em>2</em></span> }) [Optional]</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
This list of 8-byte values stores the corrected commit date offsets
      for commits with corrected commit date offsets that cannot be
      stored within 31 bits.
</li><li class="listitem">
Generation Data Overflow chunk is present only when Generation Data
      chunk is present and at least one corrected commit date offset cannot
      be stored within 31 bits.
</li></ul></div></div><div class="section" title="Extra Edge List (ID: {E, D, G, E}) [Optional]"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)__extra_edge_list_id_emphasis_e_emphasis_emphasis_d_emphasis_emphasis_g_emphasis_emphasis_e_emphasis_optional"></a>Extra Edge List (ID: {<span class="emphasis"><em>E</em></span>, <span class="emphasis"><em>D</em></span>, <span class="emphasis"><em>G</em></span>, <span class="emphasis"><em>E</em></span>}) [Optional]</h3></div></div></div><pre class="literallayout">This list of 4-byte values store the second through nth parents for
all octopus merges. The second parent value in the commit data stores
an array position within this list along with the most-significant bit
on. Starting at that array position, iterate through this list of commit
positions for the parents until reaching a value with the most-significant
bit on. The other bits correspond to the position of the last parent.</pre></div><div class="section" title="Bloom Filter Index (ID: {B, I, D, X}) (N * 4 bytes) [Optional]"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)__bloom_filter_index_id_emphasis_b_emphasis_emphasis_i_emphasis_emphasis_d_emphasis_emphasis_x_emphasis_n_4_bytes_optional"></a>Bloom Filter Index (ID: {<span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>I</em></span>, <span class="emphasis"><em>D</em></span>, <span class="emphasis"><em>X</em></span>}) (N * 4 bytes) [Optional]</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The ith entry, BIDX[i], stores the number of bytes in all Bloom filters
      from commit 0 to commit i (inclusive) in lexicographic order. The Bloom
      filter for the i-th commit spans from BIDX[i-1] to BIDX[i] (plus header
      length), where BIDX[-1] is 0.
</li><li class="listitem">
The BIDX chunk is ignored if the BDAT chunk is not present.
</li></ul></div></div><div class="section" title="Bloom Filter Data (ID: {B, D, A, T}) [Optional]"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)__bloom_filter_data_id_emphasis_b_emphasis_emphasis_d_emphasis_emphasis_a_emphasis_emphasis_t_emphasis_optional"></a>Bloom Filter Data (ID: {<span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>D</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>T</em></span>}) [Optional]</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
It starts with header consisting of three unsigned 32-bit integers:
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
Version of the hash algorithm being used. We currently support
        value 2 which corresponds to the 32-bit version of the murmur3 hash
        implemented exactly as described in
        <a class="ulink" href="https://en.wikipedia.org/wiki/MurmurHash#Algorithm" target="_blank">https://en.wikipedia.org/wiki/MurmurHash#Algorithm</a> and the double
        hashing technique using seed values 0x293ae76f and 0x7e646e2 as
        described in <a class="ulink" href="https://doi.org/10.1007/978-3-540-30494-4_26" target="_blank">https://doi.org/10.1007/978-3-540-30494-4_26</a> "Bloom Filters
        in Probabilistic Verification". Version 1 Bloom filters have a bug that appears
        when char is signed and the repository has path names that have characters &gt;=
        0x80; Git supports reading and writing them, but this ability will be removed
        in a future version of Git.
</li><li class="listitem">
The number of times a path is hashed and hence the number of bit positions
              that cumulatively determine whether a file is present in the commit.
</li><li class="listitem">
The minimum number of bits <span class="emphasis"><em>b</em></span> per entry in the Bloom filter. If the filter
              contains <span class="emphasis"><em>n</em></span> entries, then the filter size is the minimum number of 64-bit
              words that contain n*b bits.
</li></ul></div></li><li class="listitem">
The rest of the chunk is the concatenation of all the computed Bloom
      filters for the commits in lexicographic order.
</li><li class="listitem">
Note: Commits with no changes or more than 512 changes have Bloom filters
      of length one, with either all bits set to zero or one respectively.
</li><li class="listitem">
The BDAT chunk is present if and only if BIDX is present.
</li></ul></div></div><div class="section" title="Base Graphs List (ID: {B, A, S, E}) [Optional]"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-commit-graph(5)__base_graphs_list_id_emphasis_b_emphasis_emphasis_a_emphasis_emphasis_s_emphasis_emphasis_e_emphasis_optional"></a>Base Graphs List (ID: {<span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>S</em></span>, <span class="emphasis"><em>E</em></span>}) [Optional]</h3></div></div></div><pre class="literallayout">This list of H-byte hashes describe a set of B commit-graph files that
form a commit-graph chain. The graph position for the ith commit in this
file's OID Lookup chunk is equal to i plus the number of commits in all
base graphs.  If B is non-zero, this chunk must exist.</pre></div></div><div class="section" title="TRAILER:"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-commit-graph(5)__trailer"></a>TRAILER:</h2></div></div></div><pre class="literallayout">H-byte HASH-checksum of all of the above.</pre></div></div><div class="simplesect" title="Historical Notes:"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-commit-graph(5)__historical_notes"></a>Historical Notes:</h4></div></div></div><p>The Generation Data (GDA2) and Generation Data Overflow (GDO2) chunks have
the number <span class="emphasis"><em>2</em></span> in their chunk IDs because a previous version of Git wrote
possibly erroneous data in these chunks with the IDs "GDAT" and "GDOV". By
changing the IDs, newer versions of Git will silently ignore those older
chunks and write the new information without trusting the incorrect data.</p></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-commit-graph(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitformat-index(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-index(5)"></a>gitformat-index(5)</h3></div></div></div><a class="indexterm" name="id1544257"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__name"></a>NAME</h4></div></div></div><p>gitformat-index - Git index format</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>$GIT_DIR/index</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__description"></a>DESCRIPTION</h4></div></div></div><p>Git index format</p></div><div class="simplesect" title="The Git index file has the following format"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__the_git_index_file_has_the_following_format"></a>The Git index file has the following format</h4></div></div></div><pre class="literallayout">All binary numbers are in network byte order.
In a repository using the traditional SHA-1, checksums and object IDs
(object names) mentioned below are all computed using SHA-1.  Similarly,
in SHA-256 repositories, these values are computed using SHA-256.
Version 2 is described here unless stated otherwise.</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
A 12-byte header consisting of
</p><pre class="literallayout">4-byte signature:
  The signature is { 'D', 'I', 'R', 'C' } (stands for "dircache")</pre><pre class="literallayout">4-byte version number:
  The current supported versions are 2, 3 and 4.</pre><pre class="literallayout">32-bit number of index entries.</pre></li><li class="listitem">
A number of sorted index entries (see below).
</li><li class="listitem"><p class="simpara">
Extensions
</p><pre class="literallayout">Extensions are identified by signature. Optional extensions can
be ignored if Git does not understand them.</pre><pre class="literallayout">4-byte extension signature. If the first byte is 'A'..'Z' the
extension is optional and can be ignored.</pre><pre class="literallayout">32-bit size of the extension</pre><pre class="literallayout">Extension data</pre></li><li class="listitem">
Hash checksum over the content of the index file before this checksum.
</li></ul></div></div><div class="simplesect" title="Index entry"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__index_entry"></a>Index entry</h4></div></div></div><pre class="literallayout">Index entries are sorted in ascending order on the name field,
interpreted as a string of unsigned bytes (i.e. memcmp() order, no
localization, no special casing of directory separator '/'). Entries
with the same name are sorted by their stage field.</pre><pre class="literallayout">An index entry typically represents a file. However, if sparse-checkout
is enabled in cone mode (`core.sparseCheckoutCone` is enabled) and the
`extensions.sparseIndex` extension is enabled, then the index may
contain entries for directories outside of the sparse-checkout definition.
These entries have mode `040000`, include the `SKIP_WORKTREE` bit, and
the path ends in a directory separator.</pre><pre class="literallayout">32-bit ctime seconds, the last time a file's metadata changed
  this is stat(2) data</pre><pre class="literallayout">32-bit ctime nanosecond fractions
  this is stat(2) data</pre><pre class="literallayout">32-bit mtime seconds, the last time a file's data changed
  this is stat(2) data</pre><pre class="literallayout">32-bit mtime nanosecond fractions
  this is stat(2) data</pre><pre class="literallayout">32-bit dev
  this is stat(2) data</pre><pre class="literallayout">32-bit ino
  this is stat(2) data</pre><pre class="literallayout">32-bit mode, split into (high to low bits)</pre><pre class="literallayout">16-bit unused, must be zero</pre><pre class="literallayout">4-bit object type
  valid values in binary are 1000 (regular file), 1010 (symbolic link)
  and 1110 (gitlink)</pre><pre class="literallayout">3-bit unused, must be zero</pre><pre class="literallayout">9-bit unix permission. Only 0755 and 0644 are valid for regular files.
Symbolic links and gitlinks have value 0 in this field.</pre><pre class="literallayout">32-bit uid
  this is stat(2) data</pre><pre class="literallayout">32-bit gid
  this is stat(2) data</pre><pre class="literallayout">32-bit file size
  This is the on-disk size from stat(2), truncated to 32-bit.</pre><pre class="literallayout">Object name for the represented object</pre><pre class="literallayout">A 16-bit 'flags' field split into (high to low bits)</pre><pre class="literallayout">1-bit assume-valid flag</pre><pre class="literallayout">1-bit extended flag (must be zero in version 2)</pre><pre class="literallayout">2-bit stage (during merge)</pre><pre class="literallayout">12-bit name length if the length is less than 0xFFF; otherwise 0xFFF
is stored in this field.</pre><pre class="literallayout">(Version 3 or later) A 16-bit field, only applicable if the
"extended flag" above is 1, split into (high to low bits).</pre><pre class="literallayout">1-bit reserved for future</pre><pre class="literallayout">1-bit skip-worktree flag (used by sparse checkout)</pre><pre class="literallayout">1-bit intent-to-add flag (used by "git add -N")</pre><pre class="literallayout">13-bit unused, must be zero</pre><pre class="literallayout">Entry path name (variable length) relative to top level directory
  (without leading slash). '/' is used as path separator. The special
  path components ".", ".." and ".git" (without quotes) are disallowed.
  Trailing slash is also disallowed.</pre><pre class="literallayout">The exact encoding is undefined, but the '.' and '/' characters
are encoded in 7-bit ASCII and the encoding cannot contain a NUL
byte (iow, this is a UNIX pathname).</pre><pre class="literallayout">(Version 4) In version 4, the entry path name is prefix-compressed
  relative to the path name for the previous entry (the very first
  entry is encoded as if the path name for the previous entry is an
  empty string).  At the beginning of an entry, an integer N in the
  variable width encoding (the same encoding as the offset is encoded
  for OFS_DELTA pack entries; see linkgit:gitformat-pack[5]) is stored, followed
  by a NUL-terminated string S.  Removing N bytes from the end of the
  path name for the previous entry, and replacing it with the string S
  yields the path name for this entry.</pre><pre class="literallayout">1-8 nul bytes as necessary to pad the entry to a multiple of eight bytes
while keeping the name NUL-terminated.</pre><pre class="literallayout">(Version 4) In version 4, the padding after the pathname does not
exist.</pre><pre class="literallayout">Interpretation of index entries in split index mode is completely
different. See below for details.</pre></div><div class="simplesect" title="Extensions"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__extensions"></a>Extensions</h4></div></div></div><div class="section" title="Cache tree"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-index(5)__cache_tree"></a>Cache tree</h2></div></div></div><pre class="literallayout">Since the index does not record entries for directories, the cache
entries cannot describe tree objects that already exist in the object
database for regions of the index that are unchanged from an existing
commit. The cache tree extension stores a recursive tree structure that
describes the trees that already exist and completely match sections of
the cache entries. This speeds up tree object generation from the index
for a new commit by only computing the trees that are "new" to that
commit. It also assists when comparing the index to another tree, such
as `HEAD^{tree}`, since sections of the index can be skipped when a tree
comparison demonstrates equality.</pre><pre class="literallayout">The recursive tree structure uses nodes that store a number of cache
entries, a list of subnodes, and an object ID (OID). The OID references
the existing tree for that node, if it is known to exist. The subnodes
correspond to subdirectories that themselves have cache tree nodes. The
number of cache entries corresponds to the number of cache entries in
the index that describe paths within that tree's directory.</pre><pre class="literallayout">The extension tracks the full directory structure in the cache tree
extension, but this is generally smaller than the full cache entry list.</pre><pre class="literallayout">When a path is updated in index, Git invalidates all nodes of the
recursive cache tree corresponding to the parent directories of that
path. We store these tree nodes as being "invalid" by using "-1" as the
number of cache entries. Invalid nodes still store a span of index
entries, allowing Git to focus its efforts when reconstructing a full
cache tree.</pre><pre class="literallayout">The signature for this extension is { 'T', 'R', 'E', 'E' }.</pre><pre class="literallayout">A series of entries fill the entire extension; each of which
consists of:</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
NUL-terminated path component (relative to its parent directory);
</li><li class="listitem">
ASCII decimal number of entries in the index that is covered by the
    tree this entry represents (entry_count);
</li><li class="listitem">
A space (ASCII 32);
</li><li class="listitem">
ASCII decimal number that represents the number of subtrees this
    tree has;
</li><li class="listitem">
A newline (ASCII 10); and
</li><li class="listitem"><p class="simpara">
Object name for the object that would result from writing this span
    of index as a tree.
</p><pre class="literallayout">An entry can be in an invalidated state and is represented by having
a negative number in the entry_count field. In this case, there is no
object name and the next entry starts immediately after the newline.
When writing an invalid entry, -1 should always be used as entry_count.</pre><pre class="literallayout">The entries are written out in the top-down, depth-first order.  The
first entry represents the root level of the repository, followed by the
first subtree--let's call this A--of the root level (with its name
relative to the root level), followed by the first subtree of A (with
its name relative to A), and so on. The specified number of subtrees
indicates when the current level of the recursive stack is complete.</pre></li></ul></div></div><div class="section" title="Resolve undo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-index(5)__resolve_undo"></a>Resolve undo</h2></div></div></div><pre class="literallayout">A conflict is represented in the index as a set of higher stage entries.
When a conflict is resolved (e.g. with "git add path"), these higher
stage entries will be removed and a stage-0 entry with proper resolution
is added.</pre><pre class="literallayout">When these higher stage entries are removed, they are saved in the
resolve undo extension, so that conflicts can be recreated (e.g. with
"git checkout -m"), in case users want to redo a conflict resolution
from scratch.</pre><pre class="literallayout">The signature for this extension is { 'R', 'E', 'U', 'C' }.</pre><pre class="literallayout">A series of entries fill the entire extension; each of which
consists of:</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
NUL-terminated pathname the entry describes (relative to the root of
    the repository, i.e. full pathname);
</li><li class="listitem">
Three NUL-terminated ASCII octal numbers, entry mode of entries in
    stage 1 to 3 (a missing stage is represented by "0" in this field);
    and
</li><li class="listitem">
At most three object names of the entry in stages from 1 to 3
    (nothing is written for a missing stage).
</li></ul></div></div><div class="section" title="Split index"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-index(5)__split_index"></a>Split index</h2></div></div></div><pre class="literallayout">In split index mode, the majority of index entries could be stored
in a separate file. This extension records the changes to be made on
top of that to produce the final index.</pre><pre class="literallayout">The signature for this extension is { 'l', 'i', 'n', 'k' }.</pre><pre class="literallayout">The extension consists of:</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Hash of the shared index file. The shared index file path
    is $GIT_DIR/sharedindex.&lt;hash&gt;. If all bits are zero, the
    index does not require a shared index file.
</li><li class="listitem">
An ewah-encoded delete bitmap, each bit represents an entry in the
    shared index. If a bit is set, its corresponding entry in the
    shared index will be removed from the final index.  Note, because
    a delete operation changes index entry positions, but we do need
    original positions in replace phase, it's best to just mark
    entries for removal, then do a mass deletion after replacement.
</li><li class="listitem"><p class="simpara">
An ewah-encoded replace bitmap, each bit represents an entry in
    the shared index. If a bit is set, its corresponding entry in the
    shared index will be replaced with an entry in this index
    file. All replaced entries are stored in sorted order in this
    index. The first "1" bit in the replace bitmap corresponds to the
    first index entry, the second "1" bit to the second entry and so
    on. Replaced entries may have empty path names to save space.
</p><pre class="literallayout">The remaining index entries after replaced ones will be added to the
final index. These added entries are also sorted by entry name then
stage.</pre></li></ul></div></div></div><div class="simplesect" title="Untracked cache"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__untracked_cache"></a>Untracked cache</h4></div></div></div><pre class="literallayout">Untracked cache saves the untracked file list and necessary data to
verify the cache. The signature for this extension is { 'U', 'N',
'T', 'R' }.</pre><pre class="literallayout">The extension starts with</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A sequence of NUL-terminated strings, preceded by the size of the
    sequence in variable width encoding. Each string describes the
    environment where the cache can be used.
</li><li class="listitem">
Stat data of $GIT_DIR/info/exclude. See "Index entry" section from
    ctime field until "file size".
</li><li class="listitem">
Stat data of core.excludesFile
</li><li class="listitem">
32-bit dir_flags (see struct dir_struct)
</li><li class="listitem">
Hash of $GIT_DIR/info/exclude. A null hash means the file
    does not exist.
</li><li class="listitem">
Hash of core.excludesFile. A null hash means the file does
    not exist.
</li><li class="listitem">
NUL-terminated string of per-dir exclude file name. This usually
    is ".gitignore".
</li><li class="listitem">
The number of following directory blocks, variable width
    encoding. If this number is zero, the extension ends here with a
    following NUL.
</li><li class="listitem">
A number of directory blocks in depth-first-search order, each
    consists of
</li><li class="listitem">
The number of untracked entries, variable width encoding.
</li><li class="listitem">
The number of sub-directory blocks, variable width encoding.
</li><li class="listitem">
The directory name terminated by NUL.
</li><li class="listitem">
A number of untracked file/dir names terminated by NUL.
</li></ul></div><p>The remaining data of each directory block is grouped by type:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
An ewah bitmap, the n-th bit marks whether the n-th directory has
    valid untracked cache entries.
</li><li class="listitem">
An ewah bitmap, the n-th bit records "check-only" bit of
    read_directory_recursive() for the n-th directory.
</li><li class="listitem">
An ewah bitmap, the n-th bit indicates whether hash and stat data
    is valid for the n-th directory and exists in the next data.
</li><li class="listitem">
An array of stat data. The n-th data corresponds with the n-th
    "one" bit in the previous ewah bitmap.
</li><li class="listitem">
An array of hashes. The n-th hash corresponds with the n-th "one" bit
    in the previous ewah bitmap.
</li><li class="listitem">
One NUL.
</li></ul></div></div><div class="simplesect" title="File System Monitor cache"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__file_system_monitor_cache"></a>File System Monitor cache</h4></div></div></div><pre class="literallayout">The file system monitor cache tracks files for which the core.fsmonitor
hook has told us about changes.  The signature for this extension is
{ 'F', 'S', 'M', 'N' }.</pre><pre class="literallayout">The extension starts with</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
32-bit version number: the current supported versions are 1 and 2.
</li><li class="listitem">
(Version 1)
    64-bit time: the extension data reflects all changes through the given
        time which is stored as the nanoseconds elapsed since midnight,
        January 1, 1970.
</li><li class="listitem">
(Version 2)
    A null terminated string: an opaque token defined by the file system
    monitor application.  The extension data reflects all changes relative
    to that token.
</li><li class="listitem">
32-bit bitmap size: the size of the CE_FSMONITOR_VALID bitmap.
</li><li class="listitem">
An ewah bitmap, the n-th bit indicates whether the n-th index entry
    is not CE_FSMONITOR_VALID.
</li></ul></div></div><div class="simplesect" title="End of Index Entry"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__end_of_index_entry"></a>End of Index Entry</h4></div></div></div><pre class="literallayout">The End of Index Entry (EOIE) is used to locate the end of the variable
length index entries and the beginning of the extensions. Code can take
advantage of this to quickly locate the index extensions without having
to parse through all of the index entries.</pre><pre class="literallayout">Because it must be able to be loaded before the variable length cache
entries and other index extensions, this extension must be written last.
The signature for this extension is { 'E', 'O', 'I', 'E' }.</pre><pre class="literallayout">The extension consists of:</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
32-bit offset to the end of the index entries
</li><li class="listitem"><p class="simpara">
Hash over the extension types and their sizes (but not
        their contents).  E.g. if we have "TREE" extension that is N-bytes
        long, "REUC" extension that is M-bytes long, followed by "EOIE",
        then the hash would be:
</p><pre class="literallayout">Hash("TREE" + &lt;binary-representation-of-N&gt; +
        "REUC" + &lt;binary-representation-of-M&gt;)</pre></li></ul></div></div><div class="simplesect" title="Index Entry Offset Table"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__index_entry_offset_table"></a>Index Entry Offset Table</h4></div></div></div><pre class="literallayout">The Index Entry Offset Table (IEOT) is used to help address the CPU
cost of loading the index by enabling multi-threading the process of
converting cache entries from the on-disk format to the in-memory format.
The signature for this extension is { 'I', 'E', 'O', 'T' }.</pre><pre class="literallayout">The extension consists of:</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
32-bit version (currently 1)
</li><li class="listitem">
A number of index offset entries each consisting of:
</li><li class="listitem">
32-bit offset from the beginning of the file to the first cache entry
        in this block of entries.
</li><li class="listitem">
32-bit count of cache entries in this block
</li></ul></div></div><div class="simplesect" title="Sparse Directory Entries"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__sparse_directory_entries"></a>Sparse Directory Entries</h4></div></div></div><pre class="literallayout">When using sparse-checkout in cone mode, some entire directories within
the index can be summarized by pointing to a tree object instead of the
entire expanded list of paths within that tree. An index containing such
entries is a "sparse index". Index format versions 4 and less were not
implemented with such entries in mind. Thus, for these versions, an
index containing sparse directory entries will include this extension
with signature { 's', 'd', 'i', 'r' }. Like the split-index extension,
tools should avoid interacting with a sparse index unless they understand
this extension.</pre></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-index(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitformat-pack(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-pack(5)"></a>gitformat-pack(5)</h3></div></div></div><a class="indexterm" name="id1547513"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__name"></a>NAME</h4></div></div></div><p>gitformat-pack - Git pack format</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>$GIT_DIR/objects/pack/pack-<span class="strong"><strong>.{pack,idx}<br>
$GIT_DIR/objects/pack/pack-</strong></span>.rev<br>
$GIT_DIR/objects/pack/pack-*.mtimes<br>
$GIT_DIR/objects/pack/multi-pack-index</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__description"></a>DESCRIPTION</h4></div></div></div><p>The Git pack format is how Git stores most of its primary repository
data. Over the lifetime of a repository, loose objects (if any) and
smaller packs are consolidated into larger pack(s). See
<a class="xref" href="git-command.html#git-gc(1)" title="git-gc(1)">the section called “git-gc(1)”</a> and <a class="xref" href="git-command.html#git-pack-objects(1)" title="git-pack-objects(1)">the section called “git-pack-objects(1)”</a>.</p><p>The pack format is also used over-the-wire, see
e.g. <a class="xref" href="git-developerinfo.html#gitprotocol-v2(5)" title="gitprotocol-v2(5)">the section called “gitprotocol-v2(5)”</a>, as well as being a part of
other container formats in the case of <a class="xref" href="git-developerinfo.html#gitformat-bundle(5)" title="gitformat-bundle(5)">the section called “gitformat-bundle(5)”</a>.</p></div><div class="simplesect" title="Checksums and object IDs"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__checksums_and_object_ids"></a>Checksums and object IDs</h4></div></div></div><p>In a repository using the traditional SHA-1, pack checksums, index checksums,
and object IDs (object names) mentioned below are all computed using SHA-1.
Similarly, in SHA-256 repositories, these values are computed using SHA-256.</p></div><div class="simplesect" title="pack-*.pack files have the following format:"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__pack_pack_files_have_the_following_format"></a>pack-*.pack files have the following format:</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
A header appears at the beginning and consists of the following:
</p><pre class="literallayout">4-byte signature:
    The signature is: {'P', 'A', 'C', 'K'}</pre><pre class="literallayout">4-byte version number (network byte order):
    Git currently accepts version number 2 or 3 but
    generates version 2 only.</pre><pre class="literallayout">4-byte number of objects contained in the pack (network byte order)</pre><pre class="literallayout">Observation: we cannot have more than 4G versions ;-) and
more than 4G objects in a pack.</pre></li><li class="listitem"><p class="simpara">
The header is followed by a number of object entries, each of
     which looks like this:
</p><pre class="literallayout">(undeltified representation)
n-byte type and length (3-bit type, (n-1)*7+4-bit length)
compressed data</pre><pre class="literallayout">(deltified representation)
n-byte type and length (3-bit type, (n-1)*7+4-bit length)
base object name if OBJ_REF_DELTA or a negative relative
    offset from the delta object's position in the pack if this
    is an OBJ_OFS_DELTA object
compressed delta data</pre><pre class="literallayout">Observation: the length of each object is encoded in a variable
length format and is not constrained to 32-bit or anything.</pre></li><li class="listitem">
The trailer records a pack checksum of all of the above.
</li></ul></div><div class="section" title="Object types"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-pack(5)__object_types"></a>Object types</h2></div></div></div><p>Valid object types are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
OBJ_COMMIT (1)
</li><li class="listitem">
OBJ_TREE (2)
</li><li class="listitem">
OBJ_BLOB (3)
</li><li class="listitem">
OBJ_TAG (4)
</li><li class="listitem">
OBJ_OFS_DELTA (6)
</li><li class="listitem">
OBJ_REF_DELTA (7)
</li></ul></div><p>Type 5 is reserved for future expansion. Type 0 is invalid.</p></div><div class="section" title="Size encoding"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-pack(5)__size_encoding"></a>Size encoding</h2></div></div></div><p>This document uses the following "size encoding" of non-negative
integers: From each byte, the seven least significant bits are
used to form the resulting integer. As long as the most significant
bit is 1, this process continues; the byte with MSB 0 provides the
last seven bits.  The seven-bit chunks are concatenated. Later
values are more significant.</p><p>This size encoding should not be confused with the "offset encoding",
which is also used in this document.</p></div><div class="section" title="Deltified representation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-pack(5)__deltified_representation"></a>Deltified representation</h2></div></div></div><p>Conceptually there are only four object types: commit, tree, tag and
blob. However to save space, an object could be stored as a "delta" of
another "base" object. These representations are assigned new types
ofs-delta and ref-delta, which is only valid in a pack file.</p><p>Both ofs-delta and ref-delta store the "delta" to be applied to
another object (called <span class="emphasis"><em>base object</em></span>) to reconstruct the object. The
difference between them is, ref-delta directly encodes base object
name. If the base object is in the same pack, ofs-delta encodes
the offset of the base object in the pack instead.</p><p>The base object could also be deltified if it's in the same pack.
Ref-delta can also refer to an object outside the pack (i.e. the
so-called "thin pack"). When stored on disk however, the pack should
be self contained to avoid cyclic dependency.</p><p>The delta data starts with the size of the base object and the
size of the object to be reconstructed. These sizes are
encoded using the size encoding from above.  The remainder of
the delta data is a sequence of instructions to reconstruct the object
from the base object. If the base object is deltified, it must be
converted to canonical form first. Each instruction appends more and
more data to the target object until it's complete. There are two
supported instructions so far: one for copying a byte range from the
source object and one for inserting new data embedded in the
instruction itself.</p><p>Each instruction has variable length. Instruction type is determined
by the seventh bit of the first octet. The following diagrams follow
the convention in RFC 1951 (Deflate compressed data format).</p><div class="section" title="Instruction to copy from base object"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-pack(5)__instruction_to_copy_from_base_object"></a>Instruction to copy from base object</h3></div></div></div><pre class="literallayout">+----------+---------+---------+---------+---------+-------+-------+-------+
| 1xxxxxxx | offset1 | offset2 | offset3 | offset4 | size1 | size2 | size3 |
+----------+---------+---------+---------+---------+-------+-------+-------+</pre><p>This is the instruction format to copy a byte range from the source
object. It encodes the offset to copy from and the number of bytes to
copy. Offset and size are in little-endian order.</p><p>All offset and size bytes are optional. This is to reduce the
instruction size when encoding small offsets or sizes. The first seven
bits in the first octet determine which of the next seven octets is
present. If bit zero is set, offset1 is present. If bit one is set
offset2 is present and so on.</p><p>Note that a more compact instruction does not change offset and size
encoding. For example, if only offset2 is omitted like below, offset3
still contains bits 16-23. It does not become offset2 and contains
bits 8-15 even if it's right next to offset1.</p><pre class="literallayout">+----------+---------+---------+
| 10000101 | offset1 | offset3 |
+----------+---------+---------+</pre><p>In its most compact form, this instruction only takes up one byte
(0x80) with both offset and size omitted, which will have default
values zero. There is another exception: size zero is automatically
converted to 0x10000.</p></div><div class="section" title="Instruction to add new data"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-pack(5)__instruction_to_add_new_data"></a>Instruction to add new data</h3></div></div></div><pre class="literallayout">+----------+============+
| 0xxxxxxx |    data    |
+----------+============+</pre><p>This is the instruction to construct the target object without the base
object. The following data is appended to the target object. The first
seven bits of the first octet determine the size of data in
bytes. The size must be non-zero.</p></div><div class="section" title="Reserved instruction"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-pack(5)__reserved_instruction"></a>Reserved instruction</h3></div></div></div><pre class="literallayout">+----------+============
| 00000000 |
+----------+============</pre><p>This is the instruction reserved for future expansion.</p></div></div></div><div class="simplesect" title="Original (version 1) pack-*.idx files have the following format:"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__original_version_1_pack_idx_files_have_the_following_format"></a>Original (version 1) pack-*.idx files have the following format:</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The header consists of 256 4-byte network byte order
    integers.  N-th entry of this table records the number of
    objects in the corresponding pack, the first byte of whose
    object name is less than or equal to N.  This is called the
    <span class="emphasis"><em>first-level fan-out</em></span> table.
</li><li class="listitem"><p class="simpara">
The header is followed by sorted 24-byte entries, one entry
    per object in the pack.  Each entry is:
</p><pre class="literallayout">4-byte network byte order integer, recording where the
object is stored in the packfile as the offset from the
beginning.</pre><pre class="literallayout">one object name of the appropriate size.</pre></li><li class="listitem"><p class="simpara">
The file is concluded with a trailer:
</p><pre class="literallayout">A copy of the pack checksum at the end of the corresponding
packfile.</pre><pre class="literallayout">Index checksum of all of the above.</pre></li></ul></div><p>Pack Idx file:</p><pre class="literallayout">        --  +--------------------------------+
fanout      | fanout[0] = 2 (for example)    |-.
table       +--------------------------------+ |
            | fanout[1]                      | |
            +--------------------------------+ |
            | fanout[2]                      | |
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
            | fanout[255] = total objects    |---.
        --  +--------------------------------+ | |
main        | offset                         | | |
index       | object name 00XXXXXXXXXXXXXXXX | | |
table       +--------------------------------+ | |
            | offset                         | | |
            | object name 00XXXXXXXXXXXXXXXX | | |
            +--------------------------------+&lt;+ |
          .-| offset                         |   |
          | | object name 01XXXXXXXXXXXXXXXX |   |
          | +--------------------------------+   |
          | | offset                         |   |
          | | object name 01XXXXXXXXXXXXXXXX |   |
          | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   |
          | | offset                         |   |
          | | object name FFXXXXXXXXXXXXXXXX |   |
        --| +--------------------------------+&lt;--+
trailer   | | packfile checksum              |
          | +--------------------------------+
          | | idxfile checksum               |
          | +--------------------------------+
          .-------.
                  |
Pack file entry: &lt;+</pre><pre class="literallayout">packed object header:
   1-byte size extension bit (MSB)
          type (next 3 bit)
          size0 (lower 4-bit)
   n-byte sizeN (as long as MSB is set, each 7-bit)
           size0..sizeN form 4+7+7+..+7 bit integer, size0
           is the least significant part, and sizeN is the
           most significant part.
packed object data:
   If it is not DELTA, then deflated bytes (the size above
           is the size before compression).
   If it is REF_DELTA, then
     base object name (the size above is the
           size of the delta data that follows).
     delta data, deflated.
   If it is OFS_DELTA, then
     n-byte offset (see below) interpreted as a negative
           offset from the type-byte of the header of the
           ofs-delta entry (the size above is the size of
           the delta data that follows).
     delta data, deflated.</pre><pre class="literallayout">offset encoding:
     n bytes with MSB set in all but the last one.
     The offset is then the number constructed by
     concatenating the lower 7 bit of each byte, and
     for n &gt;= 2 adding 2^7 + 2^14 + ... + 2^(7*(n-1))
     to the result.</pre></div><div class="simplesect" title="Version 2 pack-*.idx files support packs larger than 4 GiB, and"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__version_2_pack_idx_files_support_packs_larger_than_4_gib_and"></a>Version 2 pack-*.idx files support packs larger than 4 GiB, and</h4></div></div></div><pre class="literallayout">have some other reorganizations.  They have the format:</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A 4-byte magic number <span class="emphasis"><em>\377tOc</em></span> which is an unreasonable
    fanout[0] value.
</li><li class="listitem">
A 4-byte version number (= 2)
</li><li class="listitem">
A 256-entry fan-out table just like v1.
</li><li class="listitem">
A table of sorted object names.  These are packed together
    without offset values to reduce the cache footprint of the
    binary search for a specific object name.
</li><li class="listitem">
A table of 4-byte CRC32 values of the packed object data.
    This is new in v2 so compressed data can be copied directly
    from pack to pack during repacking without undetected
    data corruption.
</li><li class="listitem">
A table of 4-byte offset values (in network byte order).
    These are usually 31-bit pack file offsets, but large
    offsets are encoded as an index into the next table with
    the msbit set.
</li><li class="listitem">
A table of 8-byte offset entries (empty for pack files less
    than 2 GiB).  Pack files are organized with heavily used
    objects toward the front, so most object references should
    not need to refer to this table.
</li><li class="listitem"><p class="simpara">
The same trailer as a v1 pack file:
</p><pre class="literallayout">A copy of the pack checksum at the end of the
corresponding packfile.</pre><pre class="literallayout">Index checksum of all of the above.</pre></li></ul></div></div><div class="simplesect" title="pack-*.rev files have the format:"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__pack_rev_files_have_the_format"></a>pack-*.rev files have the format:</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A 4-byte magic number <span class="emphasis"><em>0x52494458</em></span> (<span class="emphasis"><em>RIDX</em></span>).
</li><li class="listitem">
A 4-byte version identifier (= 1).
</li><li class="listitem">
A 4-byte hash function identifier (= 1 for SHA-1, 2 for SHA-256).
</li><li class="listitem">
A table of index positions (one per packed object, num_objects in
    total, each a 4-byte unsigned integer in network order), sorted by
    their corresponding offsets in the packfile.
</li><li class="listitem"><p class="simpara">
A trailer, containing a:
</p><pre class="literallayout">checksum of the corresponding packfile, and</pre><pre class="literallayout">a checksum of all of the above.</pre></li></ul></div><p>All 4-byte numbers are in network order.</p></div><div class="simplesect" title="pack-*.mtimes files have the format:"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__pack_mtimes_files_have_the_format"></a>pack-*.mtimes files have the format:</h4></div></div></div><p>All 4-byte numbers are in network byte order.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A 4-byte magic number <span class="emphasis"><em>0x4d544d45</em></span> (<span class="emphasis"><em>MTME</em></span>).
</li><li class="listitem">
A 4-byte version identifier (= 1).
</li><li class="listitem">
A 4-byte hash function identifier (= 1 for SHA-1, 2 for SHA-256).
</li><li class="listitem">
A table of 4-byte unsigned integers. The ith value is the
    modification time (mtime) of the ith object in the corresponding
    pack by lexicographic (index) order. The mtimes count standard
    epoch seconds.
</li><li class="listitem">
A trailer, containing a checksum of the corresponding packfile,
    and a checksum of all of the above (each having length according
    to the specified hash function).
</li></ul></div></div><div class="simplesect" title="multi-pack-index (MIDX) files have the following format:"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__multi_pack_index_midx_files_have_the_following_format"></a>multi-pack-index (MIDX) files have the following format:</h4></div></div></div><p>The multi-pack-index files refer to multiple pack-files and loose objects.</p><p>In order to allow extensions that add extra data to the MIDX, we organize
the body into "chunks" and provide a lookup table at the beginning of the
body. The header includes certain length values, such as the number of packs,
the number of base MIDX files, hash lengths and types.</p><p>All 4-byte numbers are in network order.</p><p>HEADER:</p><pre class="literallayout">4-byte signature:
    The signature is: {'M', 'I', 'D', 'X'}</pre><pre class="literallayout">1-byte version number:
    Git only writes or recognizes version 1.</pre><pre class="literallayout">1-byte Object Id Version
    We infer the length of object IDs (OIDs) from this value:
        1 =&gt; SHA-1
        2 =&gt; SHA-256
    If the hash type does not match the repository's hash algorithm,
    the multi-pack-index file should be ignored with a warning
    presented to the user.</pre><pre class="literallayout">1-byte number of "chunks"</pre><pre class="literallayout">1-byte number of base multi-pack-index files:
    This value is currently always zero.</pre><pre class="literallayout">4-byte number of pack files</pre><p>CHUNK LOOKUP:</p><pre class="literallayout">(C + 1) * 12 bytes providing the chunk offsets:
    First 4 bytes describe chunk id. Value 0 is a terminating label.
    Other 8 bytes provide offset in current file for chunk to start.
    (Chunks are provided in file-order, so you can infer the length
    using the next chunk position if necessary.)</pre><pre class="literallayout">The CHUNK LOOKUP matches the table of contents from
the chunk-based file format, see linkgit:gitformat-chunk[5].</pre><pre class="literallayout">The remaining data in the body is described one chunk at a time, and
these chunks may be given in any order. Chunks are required unless
otherwise specified.</pre><p>CHUNK DATA:</p><pre class="literallayout">Packfile Names (ID: {'P', 'N', 'A', 'M'})
    Store the names of packfiles as a sequence of NUL-terminated
    strings. There is no extra padding between the filenames,
    and they are listed in lexicographic order. The chunk itself
    is padded at the end with between 0 and 3 NUL bytes to make the
    chunk size a multiple of 4 bytes.</pre><pre class="literallayout">Bitmapped Packfiles (ID: {'B', 'T', 'M', 'P'})
    Stores a table of two 4-byte unsigned integers in network order.
    Each table entry corresponds to a single pack (in the order that
    they appear above in the `PNAM` chunk). The values for each table
    entry are as follows:
    - The first bit position (in pseudo-pack order, see below) to
      contain an object from that pack.
    - The number of bits whose objects are selected from that pack.</pre><pre class="literallayout">OID Fanout (ID: {'O', 'I', 'D', 'F'})
    The ith entry, F[i], stores the number of OIDs with first
    byte at most i. Thus F[255] stores the total
    number of objects.</pre><pre class="literallayout">OID Lookup (ID: {'O', 'I', 'D', 'L'})
    The OIDs for all objects in the MIDX are stored in lexicographic
    order in this chunk.</pre><pre class="literallayout">Object Offsets (ID: {'O', 'O', 'F', 'F'})
    Stores two 4-byte values for every object.
    1: The pack-int-id for the pack storing this object.
    2: The offset within the pack.
        If all offsets are less than 2^32, then the large offset chunk
        will not exist and offsets are stored as in IDX v1.
        If there is at least one offset value larger than 2^32-1, then
        the large offset chunk must exist, and offsets larger than
        2^31-1 must be stored in it instead. If the large offset chunk
        exists and the 31st bit is on, then removing that bit reveals
        the row in the large offsets containing the 8-byte offset of
        this object.</pre><pre class="literallayout">[Optional] Object Large Offsets (ID: {'L', 'O', 'F', 'F'})
    8-byte offsets into large packfiles.</pre><pre class="literallayout">[Optional] Bitmap pack order (ID: {'R', 'I', 'D', 'X'})
    A list of MIDX positions (one per object in the MIDX, num_objects in
    total, each a 4-byte unsigned integer in network byte order), sorted
    according to their relative bitmap/pseudo-pack positions.</pre><p>TRAILER:</p><pre class="literallayout">Index checksum of the above contents.</pre></div><div class="simplesect" title="multi-pack-index reverse indexes"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__multi_pack_index_reverse_indexes"></a>multi-pack-index reverse indexes</h4></div></div></div><p>Similar to the pack-based reverse index, the multi-pack index can also
be used to generate a reverse index.</p><p>Instead of mapping between offset, pack-, and index position, this
reverse index maps between an object's position within the MIDX, and
that object's position within a pseudo-pack that the MIDX describes
(i.e., the ith entry of the multi-pack reverse index holds the MIDX
position of ith object in pseudo-pack order).</p><p>To clarify the difference between these orderings, consider a multi-pack
reachability bitmap (which does not yet exist, but is what we are
building towards here). Each bit needs to correspond to an object in the
MIDX, and so we need an efficient mapping from bit position to MIDX
position.</p><p>One solution is to let bits occupy the same position in the oid-sorted
index stored by the MIDX. But because oids are effectively random, their
resulting reachability bitmaps would have no locality, and thus compress
poorly. (This is the reason that single-pack bitmaps use the pack
ordering, and not the .idx ordering, for the same purpose.)</p><p>So we'd like to define an ordering for the whole MIDX based around
pack ordering, which has far better locality (and thus compresses more
efficiently). We can think of a pseudo-pack created by the concatenation
of all of the packs in the MIDX. E.g., if we had a MIDX with three packs
(a, b, c), with 10, 15, and 20 objects respectively, we can imagine an
ordering of the objects like:</p><pre class="literallayout">|a,0|a,1|...|a,9|b,0|b,1|...|b,14|c,0|c,1|...|c,19|</pre><p>where the ordering of the packs is defined by the MIDX's pack list,
and then the ordering of objects within each pack is the same as the
order in the actual packfile.</p><p>Given the list of packs and their counts of objects, you can
naïvely reconstruct that pseudo-pack ordering (e.g., the object at
position 27 must be (c,1) because packs "a" and "b" consumed 25 of the
slots). But there's a catch. Objects may be duplicated between packs, in
which case the MIDX only stores one pointer to the object (and thus we'd
want only one slot in the bitmap).</p><p>Callers could handle duplicates themselves by reading objects in order
of their bit-position, but that's linear in the number of objects, and
much too expensive for ordinary bitmap lookups. Building a reverse index
solves this, since it is the logical inverse of the index, and that
index has already removed duplicates. But, building a reverse index on
the fly can be expensive. Since we already have an on-disk format for
pack-based reverse indexes, let's reuse it for the MIDX's pseudo-pack,
too.</p><p>Objects from the MIDX are ordered as follows to string together the
pseudo-pack. Let <span class="emphasis"><em>pack(o)</em></span> return the pack from which <span class="emphasis"><em>o</em></span> was selected
by the MIDX, and define an ordering of packs based on their numeric ID
(as stored by the MIDX). Let <span class="emphasis"><em>offset(o)</em></span> return the object offset of <span class="emphasis"><em>o</em></span>
within <span class="emphasis"><em>pack(o)</em></span>. Then, compare <span class="emphasis"><em>o1</em></span> and <span class="emphasis"><em>o2</em></span> as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
If one of <span class="emphasis"><em>pack(o1)</em></span> and <span class="emphasis"><em>pack(o2)</em></span> is preferred and the other
    is not, then the preferred one sorts first.
</p><p class="simpara">(This is a detail that allows the MIDX bitmap to determine which
pack should be used by the pack-reuse mechanism, since it can ask
the MIDX for the pack containing the object at bit position 0).</p></li><li class="listitem">
If <span class="emphasis"><em>pack(o1) ≠ pack(o2)</em></span>, then sort the two objects in descending
    order based on the pack ID.
</li><li class="listitem">
Otherwise, <span class="emphasis"><em>pack(o1) = pack(o2)</em></span>, and the objects are sorted in
    pack-order (i.e., <span class="emphasis"><em>o1</em></span> sorts ahead of <span class="emphasis"><em>o2</em></span> exactly when <span class="emphasis"><em>offset(o1)
    &lt; offset(o2)</em></span>).
</li></ul></div><p>In short, a MIDX's pseudo-pack is the de-duplicated concatenation of
objects in packs stored by the MIDX, laid out in pack order, and the
packs arranged in MIDX order (with the preferred pack coming first).</p><p>The MIDX's reverse index is stored in the optional <span class="emphasis"><em>RIDX</em></span> chunk within
the MIDX itself.</p><div class="section" title="BTMP chunk"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-pack(5)__emphasis_btmp_emphasis_chunk"></a><span class="emphasis"><em>BTMP</em></span> chunk</h2></div></div></div><p>The Bitmapped Packfiles (<span class="emphasis"><em>BTMP</em></span>) chunk encodes additional information
about the objects in the multi-pack index's reachability bitmap. Recall
that objects from the MIDX are arranged in "pseudo-pack" order (see
above) for reachability bitmaps.</p><p>From the example above, suppose we have packs "a", "b", and "c", with
10, 15, and 20 objects, respectively. In pseudo-pack order, those would
be arranged as follows:</p><pre class="literallayout">|a,0|a,1|...|a,9|b,0|b,1|...|b,14|c,0|c,1|...|c,19|</pre><p>When working with single-pack bitmaps (or, equivalently, multi-pack
reachability bitmaps with a preferred pack), <a class="xref" href="git-command.html#git-pack-objects(1)" title="git-pack-objects(1)">the section called “git-pack-objects(1)”</a>
performs verbatim reuse, attempting to reuse chunks of the bitmapped
or preferred packfile instead of adding objects to the packing list.</p><p>When a chunk of bytes is reused from an existing pack, any objects
contained therein do not need to be added to the packing list, saving
memory and CPU time. But a chunk from an existing packfile can only be
reused when the following conditions are met:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The chunk contains only objects which were requested by the caller
    (i.e. does not contain any objects which the caller didn't ask for
    explicitly or implicitly).
</li><li class="listitem">
All objects stored in non-thin packs as offset- or reference-deltas
    also include their base object in the resulting pack.
</li></ul></div><p>The <span class="emphasis"><em>BTMP</em></span> chunk encodes the necessary information in order to implement
multi-pack reuse over a set of packfiles as described above.
Specifically, the <span class="emphasis"><em>BTMP</em></span> chunk encodes three pieces of information (all
32-bit unsigned integers in network byte-order) for each packfile <span class="emphasis"><em>p</em></span>
that is stored in the MIDX, as follows:</p><div class="variablelist"><dl><dt><span class="term">
<span class="emphasis"><em>bitmap_pos</em></span>
</span></dt><dd>
The first bit position (in pseudo-pack order) in the
  multi-pack index's reachability bitmap occupied by an object from <span class="emphasis"><em>p</em></span>.
</dd><dt><span class="term">
<span class="emphasis"><em>bitmap_nr</em></span>
</span></dt><dd>
The number of bit positions (including the one at
  <span class="emphasis"><em>bitmap_pos</em></span>) that encode objects from that pack <span class="emphasis"><em>p</em></span>.
</dd></dl></div><p>For example, the <span class="emphasis"><em>BTMP</em></span> chunk corresponding to the above example (with
packs a, b, and c) would look like:</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td align="left" valign="top"><p></p></td><td align="left" valign="top"><p><span class="emphasis"><em>bitmap_pos</em></span></p></td><td align="left" valign="top"><p><span class="emphasis"><em>bitmap_nr</em></span></p></td></tr><tr><td align="left" valign="top"><p>packfile a</p></td><td align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td align="left" valign="top"><p><span class="emphasis"><em>10</em></span></p></td></tr><tr><td align="left" valign="top"><p>packfile b</p></td><td align="left" valign="top"><p><span class="emphasis"><em>10</em></span></p></td><td align="left" valign="top"><p><span class="emphasis"><em>15</em></span></p></td></tr><tr><td align="left" valign="top"><p>packfile c</p></td><td align="left" valign="top"><p><span class="emphasis"><em>25</em></span></p></td><td align="left" valign="top"><p><span class="emphasis"><em>20</em></span></p></td></tr></tbody></table></div><p>With this information in place, we can treat each packfile as
individually reusable in the same fashion as verbatim pack reuse is
performed on individual packs prior to the implementation of the <span class="emphasis"><em>BTMP</em></span>
chunk.</p></div></div><div class="simplesect" title="cruft packs"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__cruft_packs"></a>cruft packs</h4></div></div></div><p>The cruft packs feature offer an alternative to Git's traditional mechanism of
removing unreachable objects. This document provides an overview of Git's
pruning mechanism, and how a cruft pack can be used instead to accomplish the
same.</p><div class="section" title="Background"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-pack(5)__background"></a>Background</h2></div></div></div><p>To remove unreachable objects from your repository, Git offers <span class="emphasis"><em>git repack -Ad</em></span>
(see <a class="xref" href="git-command.html#git-repack(1)" title="git-repack(1)">the section called “git-repack(1)”</a>). Quoting from the documentation:</p><pre class="screen">[...] unreachable objects in a previous pack become loose, unpacked objects,
instead of being left in the old pack. [...] loose unreachable objects will be
pruned according to normal expiry rules with the next 'git gc' invocation.</pre><p>Unreachable objects aren't removed immediately, since doing so could race with
an incoming push which may reference an object which is about to be deleted.
Instead, those unreachable objects are stored as loose objects and stay that way
until they are older than the expiration window, at which point they are removed
by <a class="xref" href="git-command.html#git-prune(1)" title="git-prune(1)">the section called “git-prune(1)”</a>.</p><p>Git must store these unreachable objects loose in order to keep track of their
per-object mtimes. If these unreachable objects were written into one big pack,
then either freshening that pack (because an object contained within it was
re-written) or creating a new pack of unreachable objects would cause the pack's
mtime to get updated, and the objects within it would never leave the expiration
window. Instead, objects are stored loose in order to keep track of the
individual object mtimes and avoid a situation where all cruft objects are
freshened at once.</p><p>This can lead to undesirable situations when a repository contains many
unreachable objects which have not yet left the grace period. Having large
directories in the shards of <span class="emphasis"><em>.git/objects</em></span> can lead to decreased performance in
the repository. But given enough unreachable objects, this can lead to inode
starvation and degrade the performance of the whole system. Since we
can never pack those objects, these repositories often take up a large amount of
disk space, since we can only zlib compress them, but not store them in delta
chains.</p></div><div class="section" title="Cruft packs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-pack(5)__cruft_packs_2"></a>Cruft packs</h2></div></div></div><p>A cruft pack eliminates the need for storing unreachable objects in a loose
state by including the per-object mtimes in a separate file alongside a single
pack containing all loose objects.</p><p>A cruft pack is written by <span class="emphasis"><em>git repack --cruft</em></span> when generating a new pack.
<a class="xref" href="git-command.html#git-pack-objects(1)" title="git-pack-objects(1)">the section called “git-pack-objects(1)”</a>'s <span class="emphasis"><em>--cruft</em></span> option. Note that <span class="emphasis"><em>git repack --cruft</em></span>
is a classic all-into-one repack, meaning that everything in the resulting pack is
reachable, and everything else is unreachable. Once written, the <span class="emphasis"><em>--cruft</em></span>
option instructs <span class="emphasis"><em>git repack</em></span> to generate another pack containing only objects
not packed in the previous step (which equates to packing all unreachable
objects together). This progresses as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Enumerate every object, marking any object which is (a) not contained in a
     kept-pack, and (b) whose mtime is within the grace period as a traversal
     tip.
</li><li class="listitem">
Perform a reachability traversal based on the tips gathered in the previous
     step, adding every object along the way to the pack.
</li><li class="listitem">
Write the pack out, along with a <span class="emphasis"><em>.mtimes</em></span> file that records the per-object
     timestamps.
</li></ol></div><p>This mode is invoked internally by <a class="xref" href="git-command.html#git-repack(1)" title="git-repack(1)">the section called “git-repack(1)”</a> when instructed to
write a cruft pack. Crucially, the set of in-core kept packs is exactly the set
of packs which will not be deleted by the repack; in other words, they contain
all of the repository's reachable objects.</p><p>When a repository already has a cruft pack, <span class="emphasis"><em>git repack --cruft</em></span> typically only
adds objects to it. An exception to this is when <span class="emphasis"><em>git repack</em></span> is given the
<span class="emphasis"><em>--cruft-expiration</em></span> option, which allows the generated cruft pack to omit
expired objects instead of waiting for <a class="xref" href="git-command.html#git-gc(1)" title="git-gc(1)">the section called “git-gc(1)”</a> to expire those objects
later on.</p><p>It is <a class="xref" href="git-command.html#git-gc(1)" title="git-gc(1)">the section called “git-gc(1)”</a> that is typically responsible for removing expired
unreachable objects.</p></div><div class="section" title="Alternatives"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitformat-pack(5)__alternatives"></a>Alternatives</h2></div></div></div><p>Notable alternatives to this design include:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The location of the per-object mtime data.
</li></ul></div><p>On the location of mtime data, a new auxiliary file tied to the pack was chosen
to avoid complicating the <span class="emphasis"><em>.idx</em></span> format. If the <span class="emphasis"><em>.idx</em></span> format were ever to gain
support for optional chunks of data, it may make sense to consolidate the
<span class="emphasis"><em>.mtimes</em></span> format into the <span class="emphasis"><em>.idx</em></span> itself.</p></div></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-pack(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitformat-signature(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitformat-signature(5)"></a>gitformat-signature(5)</h3></div></div></div><a class="indexterm" name="id1548888"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-signature(5)__name"></a>NAME</h4></div></div></div><p>gitformat-signature - Git cryptographic signature formats</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-signature(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>&lt;[tag|commit] object header(s)&gt;<br>
&lt;over-the-wire protocol&gt;</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-signature(5)__description"></a>DESCRIPTION</h4></div></div></div><p>Git uses cryptographic signatures in various places, currently objects (tags,
commits, mergetags) and transactions (pushes). In every case, the command which
is about to create an object or transaction determines a payload from that,
calls an external program to obtain a detached signature for the payload
(<span class="emphasis"><em>gpg -bsa</em></span> in the case of PGP signatures), and embeds the signature into the
object or transaction.</p><p>Signatures begin with an "ASCII Armor" header line and end with a tail line,
which differ depending on signature type (as selected by <span class="emphasis"><em>gpg.format</em></span>, see
<a class="xref" href="git-command.html#git-config(1)" title="git-config(1)">the section called “git-config(1)”</a>). These are, for <span class="emphasis"><em>gpg.format</em></span> values:</p><div class="variablelist"><dl><dt><span class="term">
<span class="emphasis"><em>gpg</em></span> (PGP)
</span></dt><dd>
        <span class="emphasis"><em>-----BEGIN PGP SIGNATURE-----</em></span> and <span class="emphasis"><em>-----END PGP SIGNATURE-----</em></span>.
        Or, if gpg is told to produce RFC1991 signatures,
        <span class="emphasis"><em>-----BEGIN PGP MESSAGE-----</em></span> and <span class="emphasis"><em>-----END PGP MESSAGE-----</em></span>
</dd><dt><span class="term">
<span class="emphasis"><em>ssh</em></span> (SSH)
</span></dt><dd>
        <span class="emphasis"><em>-----BEGIN SSH SIGNATURE-----</em></span> and <span class="emphasis"><em>-----END SSH SIGNATURE-----</em></span>
</dd><dt><span class="term">
<span class="emphasis"><em>x509</em></span> (X.509)
</span></dt><dd>
        <span class="emphasis"><em>-----BEGIN SIGNED MESSAGE-----</em></span> and <span class="emphasis"><em>-----END SIGNED MESSAGE-----</em></span>
</dd></dl></div><p>Signatures sometimes appear as a part of the normal payload
(e.g. a signed tag has the signature block appended after the payload
that the signature applies to), and sometimes appear in the value of
an object header (e.g. a merge commit that merged a signed tag would
have the entire tag contents on its "mergetag" header).  In the case
of the latter, the usual multi-line formatting rule for object
headers applies.  I.e. the second and subsequent lines are prefixed
with a SP to signal that the line is continued from the previous
line.</p><p>This is even true for an originally empty line.  In the following
examples, the end of line that ends with a whitespace letter is
highlighted with a <span class="emphasis"><em>$</em></span> sign; if you are trying to recreate these
example by hand, do not cut and paste them--they are there
primarily to highlight extra whitespace at the end of some lines.</p><p>The signed payload and the way the signature is embedded depends
on the type of the object resp. transaction.</p></div><div class="simplesect" title="Tag signatures"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-signature(5)__tag_signatures"></a>Tag signatures</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
created by: <span class="emphasis"><em>git tag -s</em></span>
</li><li class="listitem">
payload: annotated tag object
</li><li class="listitem">
embedding: append the signature to the unsigned tag object
</li><li class="listitem">
example: tag <span class="emphasis"><em>signedtag</em></span> with subject <span class="emphasis"><em>signed tag</em></span>
</li></ul></div><pre class="screen">object 04b871796dc0420f8e7561a895b52484b701d51a
type commit
tag signedtag
tagger C O Mitter &lt;committer@example.com&gt; 1465981006 +0000

signed tag

signed tag message body
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAABAgAGBQJXYRhOAAoJEGEJLoW3InGJklkIAIcnhL7RwEb/+QeX9enkXhxn
rxfdqrvWd1K80sl2TOt8Bg/NYwrUBw/RWJ+sg/hhHp4WtvE1HDGHlkEz3y11Lkuh
8tSxS3qKTxXUGozyPGuE90sJfExhZlW4knIQ1wt/yWqM+33E9pN4hzPqLwyrdods
q8FWEqPPUbSJXoMbRPw04S5jrLtZSsUWbRYjmJCHzlhSfFWW4eFd37uquIaLUBS0
rkC3Jrx7420jkIpgFcTI2s60uhSQLzgcCwdA2ukSYIRnjg/zDkj8+3h/GaROJ72x
lZyI6HWixKJkWw8lE9aAOD9TmTW9sFJwcVAzmAuFX2kUreDUKMZduGcoRYGpD7E=
=jpXa
-----END PGP SIGNATURE-----</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
verify with: <span class="emphasis"><em>git verify-tag [-v]</em></span> or <span class="emphasis"><em>git tag -v</em></span>
</li></ul></div><pre class="screen">gpg: Signature made Wed Jun 15 10:56:46 2016 CEST using RSA key ID B7227189
gpg: Good signature from "Eris Discordia &lt;discord@example.net&gt;"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189
object 04b871796dc0420f8e7561a895b52484b701d51a
type commit
tag signedtag
tagger C O Mitter &lt;committer@example.com&gt; 1465981006 +0000

signed tag

signed tag message body</pre></div><div class="simplesect" title="Commit signatures"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-signature(5)__commit_signatures"></a>Commit signatures</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
created by: <span class="emphasis"><em>git commit -S</em></span>
</li><li class="listitem">
payload: commit object
</li><li class="listitem">
embedding: header entry <span class="emphasis"><em>gpgsig</em></span>
  (content is preceded by a space)
</li><li class="listitem">
example: commit with subject <span class="emphasis"><em>signed commit</em></span>
</li></ul></div><pre class="screen">tree eebfed94e75e7760540d1485c740902590a00332
parent 04b871796dc0420f8e7561a895b52484b701d51a
author A U Thor &lt;author@example.com&gt; 1465981137 +0000
committer C O Mitter &lt;committer@example.com&gt; 1465981137 +0000
gpgsig -----BEGIN PGP SIGNATURE-----
 Version: GnuPG v1
 $
 iQEcBAABAgAGBQJXYRjRAAoJEGEJLoW3InGJ3IwIAIY4SA6GxY3BjL60YyvsJPh/
 HRCJwH+w7wt3Yc/9/bW2F+gF72kdHOOs2jfv+OZhq0q4OAN6fvVSczISY/82LpS7
 DVdMQj2/YcHDT4xrDNBnXnviDO9G7am/9OE77kEbXrp7QPxvhjkicHNwy2rEflAA
 zn075rtEERDHr8nRYiDh8eVrefSO7D+bdQ7gv+7GsYMsd2auJWi1dHOSfTr9HIF4
 HJhWXT9d2f8W+diRYXGh4X0wYiGg6na/soXc+vdtDYBzIxanRqjg8jCAeo1eOTk1
 EdTwhcTZlI0x5pvJ3H0+4hA2jtldVtmPM4OTB0cTrEWBad7XV6YgiyuII73Ve3I=
 =jKHM
 -----END PGP SIGNATURE-----

signed commit

signed commit message body</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
verify with: <span class="emphasis"><em>git verify-commit [-v]</em></span> (or <span class="emphasis"><em>git show --show-signature</em></span>)
</li></ul></div><pre class="screen">gpg: Signature made Wed Jun 15 10:58:57 2016 CEST using RSA key ID B7227189
gpg: Good signature from "Eris Discordia &lt;discord@example.net&gt;"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189
tree eebfed94e75e7760540d1485c740902590a00332
parent 04b871796dc0420f8e7561a895b52484b701d51a
author A U Thor &lt;author@example.com&gt; 1465981137 +0000
committer C O Mitter &lt;committer@example.com&gt; 1465981137 +0000

signed commit

signed commit message body</pre></div><div class="simplesect" title="Mergetag signatures"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-signature(5)__mergetag_signatures"></a>Mergetag signatures</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
created by: <span class="emphasis"><em>git merge</em></span> on signed tag
</li><li class="listitem">
payload/embedding: the whole signed tag object is embedded into
  the (merge) commit object as header entry <span class="emphasis"><em>mergetag</em></span>
</li><li class="listitem">
example: merge of the signed tag <span class="emphasis"><em>signedtag</em></span> as above
</li></ul></div><pre class="screen">tree c7b1cff039a93f3600a1d18b82d26688668c7dea
parent c33429be94b5f2d3ee9b0adad223f877f174b05d
parent 04b871796dc0420f8e7561a895b52484b701d51a
author A U Thor &lt;author@example.com&gt; 1465982009 +0000
committer C O Mitter &lt;committer@example.com&gt; 1465982009 +0000
mergetag object 04b871796dc0420f8e7561a895b52484b701d51a
 type commit
 tag signedtag
 tagger C O Mitter &lt;committer@example.com&gt; 1465981006 +0000
 $
 signed tag
 $
 signed tag message body
 -----BEGIN PGP SIGNATURE-----
 Version: GnuPG v1
 $
 iQEcBAABAgAGBQJXYRhOAAoJEGEJLoW3InGJklkIAIcnhL7RwEb/+QeX9enkXhxn
 rxfdqrvWd1K80sl2TOt8Bg/NYwrUBw/RWJ+sg/hhHp4WtvE1HDGHlkEz3y11Lkuh
 8tSxS3qKTxXUGozyPGuE90sJfExhZlW4knIQ1wt/yWqM+33E9pN4hzPqLwyrdods
 q8FWEqPPUbSJXoMbRPw04S5jrLtZSsUWbRYjmJCHzlhSfFWW4eFd37uquIaLUBS0
 rkC3Jrx7420jkIpgFcTI2s60uhSQLzgcCwdA2ukSYIRnjg/zDkj8+3h/GaROJ72x
 lZyI6HWixKJkWw8lE9aAOD9TmTW9sFJwcVAzmAuFX2kUreDUKMZduGcoRYGpD7E=
 =jpXa
 -----END PGP SIGNATURE-----

Merge tag 'signedtag' into downstream

signed tag

signed tag message body

# gpg: Signature made Wed Jun 15 08:56:46 2016 UTC using RSA key ID B7227189
# gpg: Good signature from "Eris Discordia &lt;discord@example.net&gt;"
# gpg: WARNING: This key is not certified with a trusted signature!
# gpg:          There is no indication that the signature belongs to the owner.
# Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
verify with: verification is embedded in merge commit message by default,
  alternatively with <span class="emphasis"><em>git show --show-signature</em></span>:
</li></ul></div><pre class="screen">commit 9863f0c76ff78712b6800e199a46aa56afbcbd49
merged tag 'signedtag'
gpg: Signature made Wed Jun 15 10:56:46 2016 CEST using RSA key ID B7227189
gpg: Good signature from "Eris Discordia &lt;discord@example.net&gt;"
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189
Merge: c33429b 04b8717
Author: A U Thor &lt;author@example.com&gt;
Date:   Wed Jun 15 09:13:29 2016 +0000

    Merge tag 'signedtag' into downstream

    signed tag

    signed tag message body

    # gpg: Signature made Wed Jun 15 08:56:46 2016 UTC using RSA key ID B7227189
    # gpg: Good signature from "Eris Discordia &lt;discord@example.net&gt;"
    # gpg: WARNING: This key is not certified with a trusted signature!
    # gpg:          There is no indication that the signature belongs to the owner.
    # Primary key fingerprint: D4BE 2231 1AD3 131E 5EDA  29A4 6109 2E85 B722 7189</pre></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitformat-signature(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitpacking(7)"><div class="titlepage"><div><div><h3 class="title"><a name="gitpacking(7)"></a>gitpacking(7)</h3></div></div></div><a class="indexterm" name="id1549430"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitpacking(7)__name"></a>NAME</h4></div></div></div><p>gitpacking - Advanced concepts related to packing in Git</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitpacking(7)__synopsis"></a>SYNOPSIS</h4></div></div></div><p>gitpacking</p></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitpacking(7)__description"></a>DESCRIPTION</h4></div></div></div><p>This document aims to describe some advanced concepts related to packing
in Git.</p><p>Many concepts are currently described scattered between manual pages of
various Git commands, including <a class="xref" href="git-command.html#git-pack-objects(1)" title="git-pack-objects(1)">the section called “git-pack-objects(1)”</a>,
<a class="xref" href="git-command.html#git-repack(1)" title="git-repack(1)">the section called “git-repack(1)”</a>, and others, as well as <a class="xref" href="git-developerinfo.html#gitformat-pack(5)" title="gitformat-pack(5)">the section called “gitformat-pack(5)”</a>,
and parts of the <span class="emphasis"><em>Documentation/technical</em></span> tree.</p><p>There are many aspects of packing in Git that are not covered in this
document that instead live in the aforementioned areas. Over time, those
scattered bits may coalesce into this document.</p></div><div class="simplesect" title="Pseudo-merge bitmaps"><div class="titlepage"><div><div><h4 class="title"><a name="gitpacking(7)__pseudo_merge_bitmaps"></a>Pseudo-merge bitmaps</h4></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Pseudo-merge bitmaps are considered an experimental feature, so
the configuration and many of the ideas are subject to change.</p></div><div class="section" title="Background"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitpacking(7)__background"></a>Background</h2></div></div></div><p>Reachability bitmaps are most efficient when we have on-disk stored
bitmaps for one or more of the starting points of a traversal. For this
reason, Git prefers storing bitmaps for commits at the tips of refs,
because traversals tend to start with those points.</p><p>But if you have a large number of refs, it's not feasible to store a
bitmap for <span class="emphasis"><em>every</em></span> ref tip. It takes up space, and just OR-ing all of
those bitmaps together is expensive.</p><p>One way we can deal with that is to create bitmaps that represent
<span class="emphasis"><em>groups</em></span> of refs. When a traversal asks about the entire group, then we
can use this single bitmap instead of considering each ref individually.
Because these bitmaps represent the set of objects which would be
reachable in a hypothetical merge of all of the commits, we call them
pseudo-merge bitmaps.</p></div><div class="section" title="Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitpacking(7)__overview"></a>Overview</h2></div></div></div><p>A "pseudo-merge bitmap" is used to refer to a pair of bitmaps, as
follows:</p><div class="variablelist"><dl><dt><span class="term">
Commit bitmap
</span></dt><dd>
  A bitmap whose set bits describe the set of commits included in the
  pseudo-merge's "merge" bitmap (as below).
</dd><dt><span class="term">
Merge bitmap
</span></dt><dd>
  A bitmap whose set bits describe the reachability closure over the set
  of commits in the pseudo-merge's "commits" bitmap (as above). An
  identical bitmap would be generated for an octopus merge with the same
  set of parents as described in the commits bitmap.
</dd></dl></div><p>Pseudo-merge bitmaps can accelerate bitmap traversals when all commits
for a given pseudo-merge are listed on either side of the traversal,
either directly (by explicitly asking for them as part of the <span class="emphasis"><em>HAVES</em></span>
or <span class="emphasis"><em>WANTS</em></span>) or indirectly (by encountering them during a fill-in
traversal).</p></div><div class="section" title="Use-cases"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitpacking(7)__use_cases"></a>Use-cases</h2></div></div></div><p>For example, suppose there exists a pseudo-merge bitmap with a large
number of commits, all of which are listed in the <span class="emphasis"><em>WANTS</em></span> section of
some bitmap traversal query. When pseudo-merge bitmaps are enabled, the
bitmap machinery can quickly determine there is a pseudo-merge which
satisfies some subset of the wanted objects on either side of the query.
Then, we can inflate the EWAH-compressed bitmap, and <span class="emphasis"><em>OR</em></span> it in to the
resulting bitmap. By contrast, without pseudo-merge bitmaps, we would
have to repeat the decompression and <span class="emphasis"><em>OR</em></span>-ing step over a potentially
large number of individual bitmaps, which can take proportionally more
time.</p><p>Another benefit of pseudo-merges arises when there is some combination
of (a) a large number of references, with (b) poor bitmap coverage, and
(c) deep, nested trees, making fill-in traversal relatively expensive.
For example, suppose that there are a large enough number of tags where
bitmapping each of the tags individually is infeasible. Without
pseudo-merge bitmaps, computing the result of, say, <span class="emphasis"><em>git rev-list
--use-bitmap-index --count --objects --tags</em></span> would likely require a
large amount of fill-in traversal. But when a large quantity of those
tags are stored together in a pseudo-merge bitmap, the bitmap machinery
can take advantage of the fact that we only care about the union of
objects reachable from all of those tags, and answer the query much
faster.</p></div><div class="section" title="Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitpacking(7)__configuration"></a>Configuration</h2></div></div></div><p>Reference tips are grouped into different pseudo-merge groups according
to two criteria. A reference name matches one or more of the defined
pseudo-merge patterns, and optionally one or more capture groups within
that pattern which further partition the group.</p><p>Within a group, commits may be considered "stable", or "unstable"
depending on their age. These are adjusted by setting the
<span class="emphasis"><em>bitmapPseudoMerge.&lt;name&gt;.stableThreshold</em></span> and
<span class="emphasis"><em>bitmapPseudoMerge.&lt;name&gt;.threshold</em></span> configuration values, respectively.</p><p>All stable commits are grouped into pseudo-merges of equal size
(<span class="emphasis"><em>bitmapPseudoMerge.&lt;name&gt;.stableSize</em></span>). If the <span class="emphasis"><em>stableSize</em></span>
configuration is set to, say, 100, then the first 100 commits (ordered
by committer date) which are older than the <span class="emphasis"><em>stableThreshold</em></span> value will
form one group, the next 100 commits will form another group, and so on.</p><p>Among unstable commits, the pseudo-merge machinery will attempt to
combine older commits into large groups as opposed to newer commits
which will appear in smaller groups. This is based on the heuristic that
references whose tip commit is older are less likely to be modified to
point at a different commit than a reference whose tip commit is newer.</p><p>The size of groups is determined by a power-law decay function, and the
decay parameter roughly corresponds to "k" in <span class="emphasis"><em>f(n) = C*n^(-k/100)</em></span>,
where <span class="emphasis"><em>f(n)</em></span> describes the size of the <span class="emphasis"><em>n</em></span>-th pseudo-merge group. The
sample rate controls what percentage of eligible commits are considered
as candidates. The threshold parameter indicates the minimum age (so as
to avoid including too-recent commits in a pseudo-merge group, making it
less likely to be valid). The "maxMerges" parameter sets an upper-bound
on the number of pseudo-merge commits an individual group</p><p>The "stable"-related parameters control "stable" pseudo-merge groups,
comprised of a fixed number of commits which are older than the
configured "stable threshold" value and may be grouped together in
chunks of "stableSize" in order of age.</p><p>The exact configuration for pseudo-merges is as follows:</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The configuration options in <span class="emphasis"><em>bitmapPseudoMerge.*</em></span> are considered
EXPERIMENTAL and may be subject to change or be removed entirely in the
future. For more information about the pseudo-merge bitmap feature, see
the "Pseudo-merge bitmaps" section of <a class="xref" href="git-developerinfo.html#gitpacking(7)" title="gitpacking(7)">the section called “gitpacking(7)”</a>.</p></div><div class="variablelist"><dl><dt><span class="term">
bitmapPseudoMerge.&lt;name&gt;.pattern
</span></dt><dd><p class="simpara">
        Regular expression used to match reference names. Commits
        pointed to by references matching this pattern (and meeting
        the below criteria, like <span class="emphasis"><em>bitmapPseudoMerge.&lt;name&gt;.sampleRate</em></span>
        and <span class="emphasis"><em>bitmapPseudoMerge.&lt;name&gt;.threshold</em></span>) will be considered
        for inclusion in a pseudo-merge bitmap.
</p><p class="simpara">Commits are grouped into pseudo-merge groups based on whether or not
any reference(s) that point at a given commit match the pattern, which
is an extended regular expression.</p><p class="simpara">Within a pseudo-merge group, commits may be further grouped into
sub-groups based on the capture groups in the pattern. These
sub-groupings are formed from the regular expressions by concatenating
any capture groups from the regular expression, with a <span class="emphasis"><em>-</em></span> dash in
between.</p><p class="simpara">For example, if the pattern is <span class="emphasis"><em>refs/tags/</em></span>, then all tags (provided
they meet the below criteria) will be considered candidates for the
same pseudo-merge group. However, if the pattern is instead
<span class="emphasis"><em>refs/remotes/([0-9])+/tags/</em></span>, then tags from different remotes will
be grouped into separate pseudo-merge groups, based on the remote
number.</p></dd><dt><span class="term">
bitmapPseudoMerge.&lt;name&gt;.decay
</span></dt><dd><p class="simpara">
        Determines the rate at which consecutive pseudo-merge bitmap
        groups decrease in size. Must be non-negative. This parameter
        can be thought of as <span class="emphasis"><em>k</em></span> in the function <span class="emphasis"><em>f(n) = C * n^-k</em></span>,
        where <span class="emphasis"><em>f(n)</em></span> is the size of the `n`th group.
</p><p class="simpara">Setting the decay rate equal to <span class="emphasis"><em>0</em></span> will cause all groups to be the
same size. Setting the decay rate equal to <span class="emphasis"><em>1</em></span> will cause the <span class="emphasis"><em>n`th
group to be `1/n</em></span> the size of the initial group.  Higher values of the
decay rate cause consecutive groups to shrink at an increasing rate.
The default is <span class="emphasis"><em>1</em></span>.</p><p class="simpara">If all groups are the same size, it is possible that groups containing
newer commits will be able to be used less often than earlier groups,
since it is more likely that the references pointing at newer commits
will be updated more often than a reference pointing at an old commit.</p></dd><dt><span class="term">
bitmapPseudoMerge.&lt;name&gt;.sampleRate
</span></dt><dd>
        Determines the proportion of non-bitmapped commits (among
        reference tips) which are selected for inclusion in an
        unstable pseudo-merge bitmap. Must be between <span class="emphasis"><em>0</em></span> and <span class="emphasis"><em>1</em></span>
        (inclusive). The default is <span class="emphasis"><em>1</em></span>.
</dd><dt><span class="term">
bitmapPseudoMerge.&lt;name&gt;.threshold
</span></dt><dd>
        Determines the minimum age of non-bitmapped commits (among
        reference tips, as above) which are candidates for inclusion
        in an unstable pseudo-merge bitmap. The default is
        <span class="emphasis"><em>1.week.ago</em></span>.
</dd><dt><span class="term">
bitmapPseudoMerge.&lt;name&gt;.maxMerges
</span></dt><dd><p class="simpara">
        Determines the maximum number of pseudo-merge commits among
        which commits may be distributed.
</p><p class="simpara">For pseudo-merge groups whose pattern does not contain any capture
groups, this setting is applied for all commits matching the regular
expression. For patterns that have one or more capture groups, this
setting is applied for each distinct capture group.</p><p class="simpara">For example, if your capture group is <span class="emphasis"><em>refs/tags/</em></span>, then this setting
will distribute all tags into a maximum of <span class="emphasis"><em>maxMerges</em></span> pseudo-merge
commits. However, if your capture group is, say,
<span class="emphasis"><em>refs/remotes/([0-9]+)/tags/</em></span>, then this setting will be applied to
each remote's set of tags individually.</p><p class="simpara">Must be non-negative. The default value is 64.</p></dd><dt><span class="term">
bitmapPseudoMerge.&lt;name&gt;.stableThreshold
</span></dt><dd><p class="simpara">
        Determines the minimum age of commits (among reference tips,
        as above, however stable commits are still considered
        candidates even when they have been covered by a bitmap) which
        are candidates for a stable a pseudo-merge bitmap. The default
        is <span class="emphasis"><em>1.month.ago</em></span>.
</p><p class="simpara">Setting this threshold to a smaller value (e.g., 1.week.ago) will cause
more stable groups to be generated (which impose a one-time generation
cost) but those groups will likely become stale over time. Using a
larger value incurs the opposite penalty (fewer stable groups which are
more useful).</p></dd><dt><span class="term">
bitmapPseudoMerge.&lt;name&gt;.stableSize
</span></dt><dd>
        Determines the size (in number of commits) of a stable
        psuedo-merge bitmap. The default is <span class="emphasis"><em>512</em></span>.
</dd></dl></div></div><div class="section" title="Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitpacking(7)__examples"></a>Examples</h2></div></div></div><p>Suppose that you have a repository with a large number of references,
and you want a bare-bones configuration of pseudo-merge bitmaps that
will enhance bitmap coverage of the <span class="emphasis"><em>refs/</em></span> namespace. You may start
with a configuration like so:</p><pre class="screen">[bitmapPseudoMerge "all"]
        pattern = "refs/"
        threshold = now
        stableThreshold = never
        sampleRate = 100
        maxMerges = 64</pre><p>This will create pseudo-merge bitmaps for all references, regardless of
their age, and group them into 64 pseudo-merge commits.</p><p>If you wanted to separate tags from branches when generating
pseudo-merge commits, you would instead define the pattern with a
capture group, like so:</p><pre class="screen">[bitmapPseudoMerge "all"]
        pattern = "refs/(heads/tags)/"</pre><p>Suppose instead that you are working in a fork-network repository, with
each fork specified by some numeric ID, and whose refs reside in
<span class="emphasis"><em>refs/virtual/NNN/</em></span> (where <span class="emphasis"><em>NNN</em></span> is the numeric ID corresponding to some
fork) in the network. In this instance, you may instead write something
like:</p><pre class="screen">[bitmapPseudoMerge "all"]
        pattern = "refs/virtual/([0-9]+)/(heads|tags)/"
        threshold = now
        stableThreshold = never
        sampleRate = 100
        maxMerges = 64</pre><p>Which would generate pseudo-merge group identifiers like "1234-heads",
and "5678-tags" (for branches in fork "1234", and tags in remote "5678",
respectively).</p></div></div><div class="simplesect" title="SEE ALSO"><div class="titlepage"><div><div><h4 class="title"><a name="gitpacking(7)__see_also"></a>SEE ALSO</h4></div></div></div><p><a class="xref" href="git-command.html#git-pack-objects(1)" title="git-pack-objects(1)">the section called “git-pack-objects(1)”</a>
<a class="xref" href="git-command.html#git-repack(1)" title="git-repack(1)">the section called “git-repack(1)”</a></p></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitpacking(7)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitprotocol-capabilities(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-capabilities(5)"></a>gitprotocol-capabilities(5)</h3></div></div></div><a class="indexterm" name="id1549979"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__name"></a>NAME</h4></div></div></div><p>gitprotocol-capabilities - Protocol v0 and v1 capabilities</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>&lt;over-the-wire-protocol&gt;</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__description"></a>DESCRIPTION</h4></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>this document describes capabilities for versions 0 and 1 of the pack
protocol. For version 2, please refer to the <a class="xref" href="git-developerinfo.html#gitprotocol-v2(5)" title="gitprotocol-v2(5)">the section called “gitprotocol-v2(5)”</a>
doc.</p></div><p>Servers SHOULD support all capabilities defined in this document.</p><p>On the very first line of the initial server response of either
receive-pack and upload-pack the first reference is followed by
a NUL byte and then a list of space delimited server capabilities.
These allow the server to declare what it can and cannot support
to the client.</p><p>Client will then send a space separated list of capabilities it wants
to be in effect. The client MUST NOT ask for capabilities the server
did not say it supports.</p><p>Server MUST diagnose and abort if capabilities it does not understand
were sent.  Server MUST NOT ignore capabilities that client requested
and server advertised.  As a consequence of these rules, server MUST
NOT advertise capabilities it does not understand.</p><p>The <span class="emphasis"><em>atomic</em></span>, <span class="emphasis"><em>report-status</em></span>, <span class="emphasis"><em>report-status-v2</em></span>, <span class="emphasis"><em>delete-refs</em></span>, <span class="emphasis"><em>quiet</em></span>,
and <span class="emphasis"><em>push-cert</em></span> capabilities are sent and recognized by the receive-pack
(push to server) process.</p><p>The <span class="emphasis"><em>ofs-delta</em></span> and <span class="emphasis"><em>side-band-64k</em></span> capabilities are sent and recognized
by both upload-pack and receive-pack protocols.  The <span class="emphasis"><em>agent</em></span> and <span class="emphasis"><em>session-id</em></span>
capabilities may optionally be sent in both protocols.</p><p>All other capabilities are only recognized by the upload-pack (fetch
from server) process.</p></div><div class="simplesect" title="multi_ack"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__multi_ack"></a>multi_ack</h4></div></div></div><p>The <span class="emphasis"><em>multi_ack</em></span> capability allows the server to return "ACK obj-id
continue" as soon as it finds a commit that it can use as a common
base, between the client's wants and the client's have set.</p><p>By sending this early, the server can potentially head off the client
from walking any further down that particular branch of the client's
repository history.  The client may still need to walk down other
branches, sending have lines for those, until the server has a
complete cut across the DAG, or the client has said "done".</p><p>Without multi_ack, a client sends have lines in --date-order until
the server has found a common base.  That means the client will send
have lines that are already known by the server to be common, because
they overlap in time with another branch on which the server hasn't found
a common base yet.</p><p>For example suppose the client has commits in caps that the server
doesn't and the server has commits in lower case that the client
doesn't, as in the following diagram:</p><pre class="literallayout">   +---- u ---------------------- x
  /              +----- y
 /              /
a -- b -- c -- d -- E -- F
   \
    +--- Q -- R -- S</pre><p>If the client wants x,y and starts out by saying have F,S, the server
doesn't know what F,S is.  Eventually the client says "have d" and
the server sends "ACK d continue" to let the client know to stop
walking down that line (so don't send c-b-a), but it's not done yet,
it needs a base for x. The client keeps going with S-R-Q, until a
gets reached, at which point the server has a clear base and it all
ends.</p><p>Without multi_ack the client would have sent that c-b-a chain anyway,
interleaved with S-R-Q.</p></div><div class="simplesect" title="multi_ack_detailed"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__multi_ack_detailed"></a>multi_ack_detailed</h4></div></div></div><p>This is an extension of multi_ack that permits the client to better
understand the server's in-memory state. See <a class="xref" href="git-developerinfo.html#gitprotocol-pack(5)" title="gitprotocol-pack(5)">the section called “gitprotocol-pack(5)”</a>,
section "Packfile Negotiation" for more information.</p></div><div class="simplesect" title="no-done"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__no_done"></a>no-done</h4></div></div></div><p>This capability should only be used with the smart HTTP protocol. If
multi_ack_detailed and no-done are both present, then the sender is
free to immediately send a pack following its first "ACK obj-id ready"
message.</p><p>Without no-done in the smart HTTP protocol, the server session would
end and the client has to make another trip to send "done" before
the server can send the pack. no-done removes the last round and
thus slightly reduces latency.</p></div><div class="simplesect" title="thin-pack"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__thin_pack"></a>thin-pack</h4></div></div></div><p>A thin pack is one with deltas which reference base objects not
contained within the pack (but are known to exist at the receiving
end). This can reduce the network traffic significantly, but it
requires the receiving end to know how to "thicken" these packs by
adding the missing bases to the pack.</p><p>The upload-pack server advertises <span class="emphasis"><em>thin-pack</em></span> when it can generate
and send a thin pack. A client requests the <span class="emphasis"><em>thin-pack</em></span> capability
when it understands how to "thicken" it, notifying the server that
it can receive such a pack. A client MUST NOT request the
<span class="emphasis"><em>thin-pack</em></span> capability if it cannot turn a thin pack into a
self-contained pack.</p><p>Receive-pack, on the other hand, is assumed by default to be able to
handle thin packs, but can ask the client not to use the feature by
advertising the <span class="emphasis"><em>no-thin</em></span> capability. A client MUST NOT send a thin
pack if the server advertises the <span class="emphasis"><em>no-thin</em></span> capability.</p><p>The reasons for this asymmetry are historical. The receive-pack
program did not exist until after the invention of thin packs, so
historically the reference implementation of receive-pack always
understood thin packs. Adding <span class="emphasis"><em>no-thin</em></span> later allowed receive-pack
to disable the feature in a backwards-compatible manner.</p></div><div class="simplesect" title="side-band, side-band-64k"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__side_band_side_band_64k"></a>side-band, side-band-64k</h4></div></div></div><p>This capability means that the server can send, and the client can understand, multiplexed
progress reports and error info interleaved with the packfile itself.</p><p>These two options are mutually exclusive. A modern client always
favors <span class="emphasis"><em>side-band-64k</em></span>.</p><p>Either mode indicates that the packfile data will be streamed broken
up into packets of up to either 1000 bytes in the case of <span class="emphasis"><em>side_band</em></span>,
or 65520 bytes in the case of <span class="emphasis"><em>side_band_64k</em></span>. Each packet is made up
of a leading 4-byte pkt-line length of how much data is in the packet,
followed by a 1-byte stream code, followed by the actual data.</p><p>The stream code can be one of:</p><pre class="literallayout">1 - pack data
2 - progress messages
3 - fatal error message just before stream aborts</pre><p>The "side-band-64k" capability came about as a way for newer clients
that can handle much larger packets to request packets that are
actually crammed nearly full, while maintaining backward compatibility
for the older clients.</p><p>Further, with side-band and its up to 1000-byte messages, it's actually
999 bytes of payload and 1 byte for the stream code. With side-band-64k,
same deal, you have up to 65519 bytes of data and 1 byte for the stream
code.</p><p>The client MUST send only one of "side-band" and "side-
band-64k".  The server MUST diagnose it as an error if client requests
both.</p></div><div class="simplesect" title="ofs-delta"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__ofs_delta"></a>ofs-delta</h4></div></div></div><p>The server can send, and the client can understand, PACKv2 with delta referring to
its base by position in pack rather than by an obj-id.  That is, they can
send/read OBJ_OFS_DELTA (aka type 6) in a packfile.</p></div><div class="simplesect" title="agent"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__agent"></a>agent</h4></div></div></div><p>The server may optionally send a capability of the form <span class="emphasis"><em>agent=X</em></span> to
notify the client that the server is running version <span class="emphasis"><em>X</em></span>. The client may
optionally return its own agent string by responding with an <span class="emphasis"><em>agent=Y</em></span>
capability (but it MUST NOT do so if the server did not mention the
agent capability). The <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> strings may contain any printable
ASCII characters except space (i.e., the byte range 32 &lt; x &lt; 127), and
are typically of the form "package/version" (e.g., "git/1.8.3.1"). The
agent strings are purely informative for statistics and debugging
purposes, and MUST NOT be used to programmatically assume the presence
or absence of particular features.</p></div><div class="simplesect" title="object-format"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__object_format"></a>object-format</h4></div></div></div><p>This capability, which takes a hash algorithm as an argument, indicates
that the server supports the given hash algorithms.  It may be sent
multiple times; if so, the first one given is the one used in the ref
advertisement.</p><p>When provided by the client, this indicates that it intends to use the
given hash algorithm to communicate.  The algorithm provided must be one
that the server supports.</p><p>If this capability is not provided, it is assumed that the only
supported algorithm is SHA-1.</p></div><div class="simplesect" title="symref"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__symref"></a>symref</h4></div></div></div><p>This parameterized capability is used to inform the receiver which symbolic ref
points to which ref; for example, "symref=HEAD:refs/heads/master" tells the
receiver that HEAD points to master. This capability can be repeated to
represent multiple symrefs.</p><p>Servers SHOULD include this capability for the HEAD symref if it is one of the
refs being sent.</p><p>Clients MAY use the parameters from this capability to select the proper initial
branch when cloning a repository.</p></div><div class="simplesect" title="shallow"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__shallow"></a>shallow</h4></div></div></div><p>This capability adds "deepen", "shallow" and "unshallow" commands to
the  fetch-pack/upload-pack protocol so clients can request shallow
clones.</p></div><div class="simplesect" title="deepen-since"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__deepen_since"></a>deepen-since</h4></div></div></div><p>This capability adds "deepen-since" command to fetch-pack/upload-pack
protocol so the client can request shallow clones that are cut at a
specific time, instead of depth. Internally it's equivalent of doing
"rev-list --max-age=&lt;timestamp&gt;" on the server side. "deepen-since"
cannot be used with "deepen".</p></div><div class="simplesect" title="deepen-not"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__deepen_not"></a>deepen-not</h4></div></div></div><p>This capability adds "deepen-not" command to fetch-pack/upload-pack
protocol so the client can request shallow clones that are cut at a
specific revision, instead of depth. Internally it's equivalent of
doing "rev-list --not &lt;rev&gt;" on the server side. "deepen-not"
cannot be used with "deepen", but can be used with "deepen-since".</p></div><div class="simplesect" title="deepen-relative"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__deepen_relative"></a>deepen-relative</h4></div></div></div><p>If this capability is requested by the client, the semantics of
"deepen" command is changed. The "depth" argument is the depth from
the current shallow boundary, instead of the depth from remote refs.</p></div><div class="simplesect" title="no-progress"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__no_progress"></a>no-progress</h4></div></div></div><p>The client was started with "git clone -q" or something similar, and doesn't
want that side band 2.  Basically the client just says "I do not
wish to receive stream 2 on sideband, so do not send it to me, and if
you did, I will drop it on the floor anyway".  However, the sideband
channel 3 is still used for error responses.</p></div><div class="simplesect" title="include-tag"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__include_tag"></a>include-tag</h4></div></div></div><p>The <span class="emphasis"><em>include-tag</em></span> capability is about sending annotated tags if we are
sending objects they point to.  If we pack an object to the client, and
a tag object points exactly at that object, we pack the tag object too.
In general this allows a client to get all new annotated tags when it
fetches a branch, in a single network connection.</p><p>Clients MAY always send include-tag, hardcoding it into a request when
the server advertises this capability. The decision for a client to
request include-tag only has to do with the client's desires for tag
data, whether or not a server had advertised objects in the
refs/tags/* namespace.</p><p>Servers MUST pack the tags if their referent is packed and the client
has requested include-tags.</p><p>Clients MUST be prepared for the case where a server has ignored
include-tag and has not actually sent tags in the pack.  In such
cases the client SHOULD issue a subsequent fetch to acquire the tags
that include-tag would have otherwise given the client.</p><p>The server SHOULD send include-tag, if it supports it, regardless
of whether or not there are tags available.</p></div><div class="simplesect" title="report-status"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__report_status"></a>report-status</h4></div></div></div><p>The receive-pack process can receive a <span class="emphasis"><em>report-status</em></span> capability,
which tells it that the client wants a report of what happened after
a packfile upload and reference update.  If the pushing client requests
this capability, after unpacking and updating references the server
will respond with whether the packfile unpacked successfully and if
each reference was updated successfully.  If any of those were not
successful, it will send back an error message.  See <a class="xref" href="git-developerinfo.html#gitprotocol-pack(5)" title="gitprotocol-pack(5)">the section called “gitprotocol-pack(5)”</a>
for example messages.</p></div><div class="simplesect" title="report-status-v2"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__report_status_v2"></a>report-status-v2</h4></div></div></div><p>Capability <span class="emphasis"><em>report-status-v2</em></span> extends capability <span class="emphasis"><em>report-status</em></span> by
adding new "option" directives in order to support reference rewritten by
the "proc-receive" hook.  The "proc-receive" hook may handle a command
for a pseudo-reference which may create or update a reference with
different name, new-oid, and old-oid.  While the capability
<span class="emphasis"><em>report-status</em></span> cannot report for such case.  See <a class="xref" href="git-developerinfo.html#gitprotocol-pack(5)" title="gitprotocol-pack(5)">the section called “gitprotocol-pack(5)”</a>
for details.</p></div><div class="simplesect" title="delete-refs"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__delete_refs"></a>delete-refs</h4></div></div></div><p>If the server sends back the <span class="emphasis"><em>delete-refs</em></span> capability, it means that
it is capable of accepting a zero-id value as the target
value of a reference update.  It is not sent back by the client, it
simply informs the client that it can be sent zero-id values
to delete references.</p></div><div class="simplesect" title="quiet"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__quiet"></a>quiet</h4></div></div></div><p>If the receive-pack server advertises the <span class="emphasis"><em>quiet</em></span> capability, it is
capable of silencing human-readable progress output which otherwise may
be shown when processing the received pack. A send-pack client should
respond with the <span class="emphasis"><em>quiet</em></span> capability to suppress server-side progress
reporting if the local progress reporting is also being suppressed
(e.g., via <span class="emphasis"><em>push -q</em></span>, or if stderr does not go to a tty).</p></div><div class="simplesect" title="atomic"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__atomic"></a>atomic</h4></div></div></div><p>If the server sends the <span class="emphasis"><em>atomic</em></span> capability it is capable of accepting
atomic pushes. If the pushing client requests this capability, the server
will update the refs in one atomic transaction. Either all refs are
updated or none.</p></div><div class="simplesect" title="push-options"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__push_options"></a>push-options</h4></div></div></div><p>If the server sends the <span class="emphasis"><em>push-options</em></span> capability it is able to accept
push options after the update commands have been sent, but before the
packfile is streamed. If the pushing client requests this capability,
the server will pass the options to the pre- and post- receive hooks
that process this push request.</p></div><div class="simplesect" title="allow-tip-sha1-in-want"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__allow_tip_sha1_in_want"></a>allow-tip-sha1-in-want</h4></div></div></div><p>If the upload-pack server advertises this capability, fetch-pack may
send "want" lines with object names that exist at the server but are not
advertised by upload-pack. For historical reasons, the name of this
capability contains "sha1". Object names are always given using the
object format negotiated through the <span class="emphasis"><em>object-format</em></span> capability.</p></div><div class="simplesect" title="allow-reachable-sha1-in-want"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__allow_reachable_sha1_in_want"></a>allow-reachable-sha1-in-want</h4></div></div></div><p>If the upload-pack server advertises this capability, fetch-pack may
send "want" lines with object names that exist at the server but are not
advertised by upload-pack. For historical reasons, the name of this
capability contains "sha1". Object names are always given using the
object format negotiated through the <span class="emphasis"><em>object-format</em></span> capability.</p></div><div class="simplesect" title="push-cert=&lt;nonce&gt;"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__push_cert_lt_nonce_gt"></a>push-cert=&lt;nonce&gt;</h4></div></div></div><p>The receive-pack server that advertises this capability is willing
to accept a signed push certificate, and asks the &lt;nonce&gt; to be
included in the push certificate.  A send-pack client MUST NOT
send a push-cert packet unless the receive-pack server advertises
this capability.</p></div><div class="simplesect" title="filter"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__filter"></a>filter</h4></div></div></div><p>If the upload-pack server advertises the <span class="emphasis"><em>filter</em></span> capability,
fetch-pack may send "filter" commands to request a partial clone
or partial fetch and request that the server omit various objects
from the packfile.</p></div><div class="simplesect" title="session-id=&lt;session-id&gt;"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__session_id_lt_session_id_gt"></a>session-id=&lt;session-id&gt;</h4></div></div></div><p>The server may advertise a session ID that can be used to identify this process
across multiple requests. The client may advertise its own session ID back to
the server as well.</p><p>Session IDs should be unique to a given process. They must fit within a
packet-line, and must not contain non-printable or whitespace characters. The
current implementation uses trace2 session IDs (see
<a class="ulink" href="https://www.kernel.org/pub/software/scm/git/docs/technical/api-trace2.html" target="_blank"><em class="citetitle">api-trace2</em></a> for details), but this may change
and users of the session ID should not rely on this fact.</p></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-capabilities(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitprotocol-common(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-common(5)"></a>gitprotocol-common(5)</h3></div></div></div><a class="indexterm" name="id1550696"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-common(5)__name"></a>NAME</h4></div></div></div><p>gitprotocol-common - Things common to various protocols</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-common(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>&lt;over-the-wire-protocol&gt;</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-common(5)__description"></a>DESCRIPTION</h4></div></div></div><p>This document defines things common to various over-the-wire
protocols and file formats used in Git.</p></div><div class="simplesect" title="ABNF Notation"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-common(5)__abnf_notation"></a>ABNF Notation</h4></div></div></div><p>ABNF notation as described by RFC 5234 is used within the protocol documents,
except the following replacement core rules are used:</p><pre class="screen">  HEXDIG    =  DIGIT / "a" / "b" / "c" / "d" / "e" / "f"</pre><p>We also define the following common rules:</p><pre class="screen">  NUL       =  %x00
  zero-id   =  40*"0"
  obj-id    =  40*(HEXDIGIT)

  refname  =  "HEAD"
  refname /=  "refs/" &lt;see discussion below&gt;</pre><p>A refname is a hierarchical octet string beginning with "refs/" and
not violating the <span class="emphasis"><em>git-check-ref-format</em></span> command's validation rules.
More specifically, they:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
They can include slash <span class="emphasis"><em>/</em></span> for hierarchical (directory)
  grouping, but no slash-separated component can begin with a
  dot <span class="emphasis"><em>.</em></span>.
</li><li class="listitem">
They must contain at least one <span class="emphasis"><em>/</em></span>. This enforces the presence of a
  category like <span class="emphasis"><em>heads/</em></span>, <span class="emphasis"><em>tags/</em></span> etc. but the actual names are not
  restricted.
</li><li class="listitem">
They cannot have two consecutive dots <span class="emphasis"><em>..</em></span> anywhere.
</li><li class="listitem">
They cannot have ASCII control characters (i.e. bytes whose
  values are lower than \040, or \177 <span class="emphasis"><em>DEL</em></span>), space, tilde <span class="emphasis"><em>~</em></span>,
  caret <span class="emphasis"><em>^</em></span>, colon <span class="emphasis"><em>:</em></span>, question-mark <span class="emphasis"><em>?</em></span>, asterisk <span class="emphasis"><em>*</em></span>,
  or open bracket <span class="emphasis"><em>[</em></span> anywhere.
</li><li class="listitem">
They cannot end with a slash <span class="emphasis"><em>/</em></span> or a dot <span class="emphasis"><em>.</em></span>.
</li><li class="listitem">
They cannot end with the sequence <span class="emphasis"><em>.lock</em></span>.
</li><li class="listitem">
They cannot contain a sequence <span class="emphasis"><em>@{</em></span>.
</li><li class="listitem">
They cannot contain a <span class="emphasis"><em>\\</em></span>.
</li></ol></div></div><div class="simplesect" title="pkt-line Format"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-common(5)__pkt_line_format"></a>pkt-line Format</h4></div></div></div><p>Much (but not all) of the payload is described around pkt-lines.</p><p>A pkt-line is a variable length binary string.  The first four bytes
of the line, the pkt-len, indicates the total length of the line,
in hexadecimal.  The pkt-len includes the 4 bytes used to contain
the length's hexadecimal representation.</p><p>A pkt-line MAY contain binary data, so implementors MUST ensure
pkt-line parsing/formatting routines are 8-bit clean.</p><p>A non-binary line SHOULD BE terminated by an LF, which if present
MUST be included in the total length. Receivers MUST treat pkt-lines
with non-binary data the same whether or not they contain the trailing
LF (stripping the LF if present, and not complaining when it is
missing).</p><p>The maximum length of a pkt-line's data component is 65516 bytes.
Implementations MUST NOT send pkt-line whose length exceeds 65520
(65516 bytes of payload + 4 bytes of length data).</p><p>Implementations SHOULD NOT send an empty pkt-line ("0004").</p><p>A pkt-line with a length field of 0 ("0000"), called a flush-pkt,
is a special case and MUST be handled differently than an empty
pkt-line ("0004").</p><pre class="screen">  pkt-line     =  data-pkt / flush-pkt

  data-pkt     =  pkt-len pkt-payload
  pkt-len      =  4*(HEXDIG)
  pkt-payload  =  (pkt-len - 4)*(OCTET)

  flush-pkt    = "0000"</pre><p>Examples (as C-style strings):</p><pre class="screen">  pkt-line          actual value
  ---------------------------------
  "0006a\n"         "a\n"
  "0005a"           "a"
  "000bfoobar\n"    "foobar\n"
  "0004"            ""</pre></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-common(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitprotocol-http(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-http(5)"></a>gitprotocol-http(5)</h3></div></div></div><a class="indexterm" name="id1550950"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__name"></a>NAME</h4></div></div></div><p>gitprotocol-http - Git HTTP-based protocols</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>&lt;over-the-wire-protocol&gt;</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__description"></a>DESCRIPTION</h4></div></div></div><p>Git supports two HTTP based transfer protocols.  A "dumb" protocol
which requires only a standard HTTP server on the server end of the
connection, and a "smart" protocol which requires a Git aware CGI
(or server module).  This document describes both protocols.</p><p>As a design feature smart clients can automatically upgrade "dumb"
protocol URLs to smart URLs.  This permits all users to have the
same published URL, and the peers automatically select the most
efficient transport available to them.</p></div><div class="simplesect" title="URL Format"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__url_format"></a>URL Format</h4></div></div></div><p>URLs for Git repositories accessed by HTTP use the standard HTTP
URL syntax documented by RFC 1738, so they are of the form:</p><pre class="literallayout">http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;searchpart&gt;</pre><p>Within this documentation the placeholder <span class="emphasis"><em>$GIT_URL</em></span> will stand for
the http:// repository URL entered by the end-user.</p><p>Servers SHOULD handle all requests to locations matching <span class="emphasis"><em>$GIT_URL</em></span>, as
both the "smart" and "dumb" HTTP protocols used by Git operate
by appending additional path components onto the end of the user
supplied <span class="emphasis"><em>$GIT_URL</em></span> string.</p><p>An example of a dumb client requesting a loose object:</p><pre class="literallayout">$GIT_URL:     http://example.com:8080/git/repo.git
URL request:  http://example.com:8080/git/repo.git/objects/d0/49f6c27a2244e12041955e262a404c7faba355</pre><p>An example of a smart request to a catch-all gateway:</p><pre class="literallayout">$GIT_URL:     http://example.com/daemon.cgi?svc=git&amp;q=
URL request:  http://example.com/daemon.cgi?svc=git&amp;q=/info/refs&amp;service=git-receive-pack</pre><p>An example of a request to a submodule:</p><pre class="literallayout">$GIT_URL:     http://example.com/git/repo.git/path/submodule.git
URL request:  http://example.com/git/repo.git/path/submodule.git/info/refs</pre><p>Clients MUST strip a trailing <span class="emphasis"><em>/</em></span>, if present, from the user supplied
<span class="emphasis"><em>$GIT_URL</em></span> string to prevent empty path tokens (<span class="emphasis"><em>//</em></span>) from appearing
in any URL sent to a server.  Compatible clients MUST expand
<span class="emphasis"><em>$GIT_URL/info/refs</em></span> as <span class="emphasis"><em>foo/info/refs</em></span> and not <span class="emphasis"><em>foo//info/refs</em></span>.</p></div><div class="simplesect" title="Authentication"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__authentication"></a>Authentication</h4></div></div></div><p>Standard HTTP authentication is used if authentication is required
to access a repository, and MAY be configured and enforced by the
HTTP server software.</p><p>Because Git repositories are accessed by standard path components
server administrators MAY use directory based permissions within
their HTTP server to control repository access.</p><p>Clients SHOULD support Basic authentication as described by RFC 2617.
Servers SHOULD support Basic authentication by relying upon the
HTTP server placed in front of the Git server software.</p><p>Servers SHOULD NOT require HTTP cookies for the purposes of
authentication or access control.</p><p>Clients and servers MAY support other common forms of HTTP based
authentication, such as Digest authentication.</p></div><div class="simplesect" title="SSL"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__ssl"></a>SSL</h4></div></div></div><p>Clients and servers SHOULD support SSL, particularly to protect
passwords when relying on Basic HTTP authentication.</p></div><div class="simplesect" title="Session State"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__session_state"></a>Session State</h4></div></div></div><p>The Git over HTTP protocol (much like HTTP itself) is stateless
from the perspective of the HTTP server side.  All state MUST be
retained and managed by the client process.  This permits simple
round-robin load-balancing on the server side, without needing to
worry about state management.</p><p>Clients MUST NOT require state management on the server side in
order to function correctly.</p><p>Servers MUST NOT require HTTP cookies in order to function correctly.
Clients MAY store and forward HTTP cookies during request processing
as described by RFC 2616 (HTTP/1.1).  Servers SHOULD ignore any
cookies sent by a client.</p></div><div class="simplesect" title="General Request Processing"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__general_request_processing"></a>General Request Processing</h4></div></div></div><p>Except where noted, all standard HTTP behavior SHOULD be assumed
by both client and server.  This includes (but is not necessarily
limited to):</p><p>If there is no repository at <span class="emphasis"><em>$GIT_URL</em></span>, or the resource pointed to by a
location matching <span class="emphasis"><em>$GIT_URL</em></span> does not exist, the server MUST NOT respond
with <span class="emphasis"><em>200 OK</em></span> response.  A server SHOULD respond with
<span class="emphasis"><em>404 Not Found</em></span>, <span class="emphasis"><em>410 Gone</em></span>, or any other suitable HTTP status code
which does not imply the resource exists as requested.</p><p>If there is a repository at <span class="emphasis"><em>$GIT_URL</em></span>, but access is not currently
permitted, the server MUST respond with the <span class="emphasis"><em>403 Forbidden</em></span> HTTP
status code.</p><p>Servers SHOULD support both HTTP 1.0 and HTTP 1.1.
Servers SHOULD support chunked encoding for both request and response
bodies.</p><p>Clients SHOULD support both HTTP 1.0 and HTTP 1.1.
Clients SHOULD support chunked encoding for both request and response
bodies.</p><p>Servers MAY return ETag and/or Last-Modified headers.</p><p>Clients MAY revalidate cached entities by including If-Modified-Since
and/or If-None-Match request headers.</p><p>Servers MAY return <span class="emphasis"><em>304 Not Modified</em></span> if the relevant headers appear
in the request and the entity has not changed.  Clients MUST treat
<span class="emphasis"><em>304 Not Modified</em></span> identical to <span class="emphasis"><em>200 OK</em></span> by reusing the cached entity.</p><p>Clients MAY reuse a cached entity without revalidation if the
Cache-Control and/or Expires header permits caching.  Clients and
servers MUST follow RFC 2616 for cache controls.</p></div><div class="simplesect" title="Discovering References"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__discovering_references"></a>Discovering References</h4></div></div></div><p>All HTTP clients MUST begin either a fetch or a push exchange by
discovering the references available on the remote repository.</p><div class="section" title="Dumb Clients"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-http(5)__dumb_clients"></a>Dumb Clients</h2></div></div></div><p>HTTP clients that only support the "dumb" protocol MUST discover
references by making a request for the special info/refs file of
the repository.</p><p>Dumb HTTP clients MUST make a <span class="emphasis"><em>GET</em></span> request to <span class="emphasis"><em>$GIT_URL/info/refs</em></span>,
without any search/query parameters.</p><pre class="literallayout">C: GET $GIT_URL/info/refs HTTP/1.0</pre><pre class="literallayout">S: 200 OK
S:
S: 95dcfa3633004da0049d3d0fa03f80589cbcaf31  refs/heads/maint
S: d049f6c27a2244e12041955e262a404c7faba355  refs/heads/master
S: 2cb58b79488a98d2721cea644875a8dd0026b115  refs/tags/v1.0
S: a3c2e2402b99163d1d59756e5f207ae21cccba4c  refs/tags/v1.0^{}</pre><p>The Content-Type of the returned info/refs entity SHOULD be
<span class="emphasis"><em>text/plain; charset=utf-8</em></span>, but MAY be any content type.
Clients MUST NOT attempt to validate the returned Content-Type.
Dumb servers MUST NOT return a return type starting with
<span class="emphasis"><em>application/x-git-</em></span>.</p><p>Cache-Control headers MAY be returned to disable caching of the
returned entity.</p><p>When examining the response clients SHOULD only examine the HTTP
status code.  Valid responses are <span class="emphasis"><em>200 OK</em></span>, or <span class="emphasis"><em>304 Not Modified</em></span>.</p><p>The returned content is a UNIX formatted text file describing
each ref and its known value.  The file SHOULD be sorted by name
according to the C locale ordering.  The file SHOULD NOT include
the default ref named <span class="emphasis"><em>HEAD</em></span>.</p><pre class="literallayout">info_refs   =  *( ref_record )
ref_record  =  any_ref / peeled_ref</pre><pre class="literallayout">any_ref     =  obj-id HTAB refname LF
peeled_ref  =  obj-id HTAB refname LF
               obj-id HTAB refname "^{}" LF</pre></div><div class="section" title="Smart Clients"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-http(5)__smart_clients"></a>Smart Clients</h2></div></div></div><p>HTTP clients that support the "smart" protocol (or both the
"smart" and "dumb" protocols) MUST discover references by making
a parameterized request for the info/refs file of the repository.</p><p>The request MUST contain exactly one query parameter,
<span class="emphasis"><em>service=$servicename</em></span>, where <span class="emphasis"><em>$servicename</em></span> MUST be the service
name the client wishes to contact to complete the operation.
The request MUST NOT contain additional query parameters.</p><pre class="literallayout">C: GET $GIT_URL/info/refs?service=git-upload-pack HTTP/1.0</pre><p>dumb server reply:</p><pre class="literallayout">S: 200 OK
S:
S: 95dcfa3633004da0049d3d0fa03f80589cbcaf31  refs/heads/maint
S: d049f6c27a2244e12041955e262a404c7faba355  refs/heads/master
S: 2cb58b79488a98d2721cea644875a8dd0026b115  refs/tags/v1.0
S: a3c2e2402b99163d1d59756e5f207ae21cccba4c  refs/tags/v1.0^{}</pre><p>smart server reply:</p><pre class="literallayout">S: 200 OK
S: Content-Type: application/x-git-upload-pack-advertisement
S: Cache-Control: no-cache
S:
S: 001e# service=git-upload-pack\n
S: 0000
S: 004895dcfa3633004da0049d3d0fa03f80589cbcaf31 refs/heads/maint\0multi_ack\n
S: 003fd049f6c27a2244e12041955e262a404c7faba355 refs/heads/master\n
S: 003c2cb58b79488a98d2721cea644875a8dd0026b115 refs/tags/v1.0\n
S: 003fa3c2e2402b99163d1d59756e5f207ae21cccba4c refs/tags/v1.0^{}\n
S: 0000</pre><p>The client may send Extra Parameters (see
<a class="xref" href="git-developerinfo.html#gitprotocol-pack(5)" title="gitprotocol-pack(5)">the section called “gitprotocol-pack(5)”</a>) as a colon-separated string
in the Git-Protocol HTTP header.</p><p>Uses the <span class="emphasis"><em>--http-backend-info-refs</em></span> option to
<a class="xref" href="git-command.html#git-upload-pack(1)" title="git-upload-pack(1)">the section called “git-upload-pack(1)”</a>.</p><div class="section" title="Dumb Server Response"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-http(5)__dumb_server_response"></a>Dumb Server Response</h3></div></div></div><p>Dumb servers MUST respond with the dumb server reply format.</p><p>See the prior section under dumb clients for a more detailed
description of the dumb server response.</p></div><div class="section" title="Smart Server Response"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-http(5)__smart_server_response"></a>Smart Server Response</h3></div></div></div><p>If the server does not recognize the requested service name, or the
requested service name has been disabled by the server administrator,
the server MUST respond with the <span class="emphasis"><em>403 Forbidden</em></span> HTTP status code.</p><p>Otherwise, smart servers MUST respond with the smart server reply
format for the requested service name.</p><p>Cache-Control headers SHOULD be used to disable caching of the
returned entity.</p><p>The Content-Type MUST be <span class="emphasis"><em>application/x-$servicename-advertisement</em></span>.
Clients SHOULD fall back to the dumb protocol if another content
type is returned.  When falling back to the dumb protocol clients
SHOULD NOT make an additional request to <span class="emphasis"><em>$GIT_URL/info/refs</em></span>, but
instead SHOULD use the response already in hand.  Clients MUST NOT
continue if they do not support the dumb protocol.</p><p>Clients MUST validate the status code is either <span class="emphasis"><em>200 OK</em></span> or
<span class="emphasis"><em>304 Not Modified</em></span>.</p><p>Clients MUST validate the first five bytes of the response entity
matches the regex <span class="emphasis"><em>^[0-9a-f]{4}#</em></span>.  If this test fails, clients
MUST NOT continue.</p><p>Clients MUST parse the entire response as a sequence of pkt-line
records.</p><p>Clients MUST verify the first pkt-line is <span class="emphasis"><em># service=$servicename</em></span>.
Servers MUST set $servicename to be the request parameter value.
Servers SHOULD include an LF at the end of this line.
Clients MUST ignore an LF at the end of the line.</p><p>Servers MUST terminate the response with the magic <span class="emphasis"><em>0000</em></span> end
pkt-line marker.</p><p>The returned response is a pkt-line stream describing each ref and
its known value.  The stream SHOULD be sorted by name according to
the C locale ordering.  The stream SHOULD include the default ref
named <span class="emphasis"><em>HEAD</em></span> as the first ref.  The stream MUST include capability
declarations behind a NUL on the first ref.</p><p>The returned response contains "version 1" if "version=1" was sent as an
Extra Parameter.</p><pre class="literallayout">smart_reply     =  PKT-LINE("# service=$servicename" LF)
                   "0000"
                   *1("version 1")
                   ref_list
                   "0000"
ref_list        =  empty_list / non_empty_list</pre><pre class="literallayout">empty_list      =  PKT-LINE(zero-id SP "capabilities^{}" NUL cap-list LF)</pre><pre class="literallayout">non_empty_list  =  PKT-LINE(obj-id SP name NUL cap_list LF)
                   *ref_record</pre><pre class="literallayout">cap-list        =  capability *(SP capability)
capability      =  1*(LC_ALPHA / DIGIT / "-" / "_")
LC_ALPHA        =  %x61-7A</pre><pre class="literallayout">ref_record      =  any_ref / peeled_ref
any_ref         =  PKT-LINE(obj-id SP name LF)
peeled_ref      =  PKT-LINE(obj-id SP name LF)
                   PKT-LINE(obj-id SP name "^{}" LF</pre></div></div></div><div class="simplesect" title="Smart Service git-upload-pack"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__smart_service_git_upload_pack"></a>Smart Service git-upload-pack</h4></div></div></div><p>This service reads from the repository pointed to by <span class="emphasis"><em>$GIT_URL</em></span>.</p><p>Clients MUST first perform ref discovery with
<span class="emphasis"><em>$GIT_URL/info/refs?service=git-upload-pack</em></span>.</p><pre class="literallayout">C: POST $GIT_URL/git-upload-pack HTTP/1.0
C: Content-Type: application/x-git-upload-pack-request
C:
C: 0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7\n
C: 0032have 441b40d833fdfa93eb2908e52742248faf0ee993\n
C: 0000</pre><pre class="literallayout">S: 200 OK
S: Content-Type: application/x-git-upload-pack-result
S: Cache-Control: no-cache
S:
S: ....ACK %s, continue
S: ....NAK</pre><p>Clients MUST NOT reuse or revalidate a cached response.
Servers MUST include sufficient Cache-Control headers
to prevent caching of the response.</p><p>Servers SHOULD support all capabilities defined here.</p><p>Clients MUST send at least one "want" command in the request body.
Clients MUST NOT reference an id in a "want" command which did not
appear in the response obtained through ref discovery unless the
server advertises capability <span class="emphasis"><em>allow-tip-sha1-in-want</em></span> or
<span class="emphasis"><em>allow-reachable-sha1-in-want</em></span>.</p><pre class="literallayout">compute_request   =  want_list
                     have_list
                     request_end
request_end       =  "0000" / "done"</pre><pre class="literallayout">want_list         =  PKT-LINE(want SP cap_list LF)
                     *(want_pkt)
want_pkt          =  PKT-LINE(want LF)
want              =  "want" SP id
cap_list          =  capability *(SP capability)</pre><pre class="literallayout">have_list         =  *PKT-LINE("have" SP id LF)</pre><p>TODO: Document this further.</p><div class="section" title="The Negotiation Algorithm"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-http(5)__the_negotiation_algorithm"></a>The Negotiation Algorithm</h2></div></div></div><p>The computation to select the minimal pack proceeds as follows
(C = client, S = server):</p><p><span class="emphasis"><em>init step:</em></span></p><p>C: Use ref discovery to obtain the advertised refs.</p><p>C: Place any object seen into set <span class="emphasis"><em>advertised</em></span>.</p><p>C: Build an empty set, <span class="emphasis"><em>common</em></span>, to hold the objects that are later
   determined to be on both ends.</p><p>C: Build a set, <span class="emphasis"><em>want</em></span>, of the objects from <span class="emphasis"><em>advertised</em></span> that the client
   wants to fetch, based on what it saw during ref discovery.</p><p>C: Start a queue, <span class="emphasis"><em>c_pending</em></span>, ordered by commit time (popping newest
   first).  Add all client refs.  When a commit is popped from
   the queue its parents SHOULD be automatically inserted back.
   Commits MUST only enter the queue once.</p><p><span class="emphasis"><em>one compute step:</em></span></p><p>C: Send one <span class="emphasis"><em>$GIT_URL/git-upload-pack</em></span> request:</p><pre class="literallayout">C: 0032want &lt;want-#1&gt;...............................
C: 0032want &lt;want-#2&gt;...............................
....
C: 0032have &lt;common-#1&gt;.............................
C: 0032have &lt;common-#2&gt;.............................
....
C: 0032have &lt;have-#1&gt;...............................
C: 0032have &lt;have-#2&gt;...............................
....
C: 0000</pre><p>The stream is organized into "commands", with each command
appearing by itself in a pkt-line.  Within a command line,
the text leading up to the first space is the command name,
and the remainder of the line to the first LF is the value.
Command lines are terminated with an LF as the last byte of
the pkt-line value.</p><p>Commands MUST appear in the following order, if they appear
at all in the request stream:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
"want"
</li><li class="listitem">
"have"
</li></ul></div><p>The stream is terminated by a pkt-line flush (<span class="emphasis"><em>0000</em></span>).</p><p>A single "want" or "have" command MUST have one hex formatted
object name as its value.  Multiple object names MUST be sent by sending
multiple commands. Object names MUST be given using the object format
negotiated through the <span class="emphasis"><em>object-format</em></span> capability (default SHA-1).</p><p>The <span class="emphasis"><em>have</em></span> list is created by popping the first 32 commits
from <span class="emphasis"><em>c_pending</em></span>.  Fewer can be supplied if <span class="emphasis"><em>c_pending</em></span> empties.</p><p>If the client has sent 256 "have" commits and has not yet
received one of those back from <span class="emphasis"><em>s_common</em></span>, or the client has
emptied <span class="emphasis"><em>c_pending</em></span> it SHOULD include a "done" command to let
the server know it won't proceed:</p><pre class="literallayout">C: 0009done</pre><p>S: Parse the git-upload-pack request:</p><p>Verify all objects in <span class="emphasis"><em>want</em></span> are directly reachable from refs.</p><p>The server MAY walk backwards through history or through
the reflog to permit slightly stale requests.</p><p>If no "want" objects are received, send an error:
TODO: Define error if no "want" lines are requested.</p><p>If any "want" object is not reachable, send an error:
TODO: Define error if an invalid "want" is requested.</p><p>Create an empty list, <span class="emphasis"><em>s_common</em></span>.</p><p>If "have" was sent:</p><p>Loop through the objects in the order supplied by the client.</p><p>For each object, if the server has the object reachable from
a ref, add it to <span class="emphasis"><em>s_common</em></span>.  If a commit is added to <span class="emphasis"><em>s_common</em></span>,
do not add any ancestors, even if they also appear in <span class="emphasis"><em>have</em></span>.</p><p>S: Send the git-upload-pack response:</p><p>If the server has found a closed set of objects to pack or the
request ends with "done", it replies with the pack.
TODO: Document the pack based response</p><pre class="literallayout">S: PACK...</pre><p>The returned stream is the side-band-64k protocol supported
by the git-upload-pack service, and the pack is embedded into
stream 1.  Progress messages from the server side MAY appear
in stream 2.</p><p>Here a "closed set of objects" is defined to have at least
one path from every "want" to at least one "common" object.</p><p>If the server needs more information, it replies with a
status continue response:
TODO: Document the non-pack response</p><p>C: Parse the upload-pack response:
   TODO: Document parsing response</p><p><span class="emphasis"><em>Do another compute step.</em></span></p></div></div><div class="simplesect" title="Smart Service git-receive-pack"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__smart_service_git_receive_pack"></a>Smart Service git-receive-pack</h4></div></div></div><p>This service reads from the repository pointed to by <span class="emphasis"><em>$GIT_URL</em></span>.</p><p>Clients MUST first perform ref discovery with
<span class="emphasis"><em>$GIT_URL/info/refs?service=git-receive-pack</em></span>.</p><pre class="literallayout">C: POST $GIT_URL/git-receive-pack HTTP/1.0
C: Content-Type: application/x-git-receive-pack-request
C:
C: ....0a53e9ddeaddad63ad106860237bbf53411d11a7 441b40d833fdfa93eb2908e52742248faf0ee993 refs/heads/maint\0 report-status
C: 0000
C: PACK....</pre><pre class="literallayout">S: 200 OK
S: Content-Type: application/x-git-receive-pack-result
S: Cache-Control: no-cache
S:
S: ....</pre><p>Clients MUST NOT reuse or revalidate a cached response.
Servers MUST include sufficient Cache-Control headers
to prevent caching of the response.</p><p>Servers SHOULD support all capabilities defined here.</p><p>Clients MUST send at least one command in the request body.
Within the command portion of the request body clients SHOULD send
the id obtained through ref discovery as old_id.</p><pre class="literallayout">update_request  =  command_list
                   "PACK" &lt;binary-data&gt;</pre><pre class="literallayout">command_list    =  PKT-LINE(command NUL cap_list LF)
                   *(command_pkt)
command_pkt     =  PKT-LINE(command LF)
cap_list        =  *(SP capability) SP</pre><pre class="literallayout">command         =  create / delete / update
create          =  zero-id SP new_id SP name
delete          =  old_id SP zero-id SP name
update          =  old_id SP new_id SP name</pre><p>TODO: Document this further.</p></div><div class="simplesect" title="REFERENCES"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__references"></a>REFERENCES</h4></div></div></div><p><a class="ulink" href="https://www.ietf.org/rfc/rfc1738.txt" target="_blank">RFC 1738: Uniform Resource Locators (URL)</a>
<a class="ulink" href="https://www.ietf.org/rfc/rfc2616.txt" target="_blank">RFC 2616: Hypertext Transfer Protocol -- HTTP/1.1</a></p></div><div class="simplesect" title="SEE ALSO"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__see_also"></a>SEE ALSO</h4></div></div></div><p><a class="xref" href="git-developerinfo.html#gitprotocol-pack(5)" title="gitprotocol-pack(5)">the section called “gitprotocol-pack(5)”</a>
<a class="xref" href="git-developerinfo.html#gitprotocol-capabilities(5)" title="gitprotocol-capabilities(5)">the section called “gitprotocol-capabilities(5)”</a></p></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-http(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitprotocol-pack(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-pack(5)"></a>gitprotocol-pack(5)</h3></div></div></div><a class="indexterm" name="id1553170"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__name"></a>NAME</h4></div></div></div><p>gitprotocol-pack - How packs are transferred over-the-wire</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>&lt;over-the-wire-protocol&gt;</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__description"></a>DESCRIPTION</h4></div></div></div><p>Git supports transferring data in packfiles over the ssh://, git://, http:// and
file:// transports.  There exist two sets of protocols, one for pushing
data from a client to a server and another for fetching data from a
server to a client.  The three transports (ssh, git, file) use the same
protocol to transfer data. http is documented in <a class="xref" href="git-developerinfo.html#gitprotocol-http(5)" title="gitprotocol-http(5)">the section called “gitprotocol-http(5)”</a>.</p><p>The processes invoked in the canonical Git implementation are <span class="emphasis"><em>upload-pack</em></span>
on the server side and <span class="emphasis"><em>fetch-pack</em></span> on the client side for fetching data;
then <span class="emphasis"><em>receive-pack</em></span> on the server and <span class="emphasis"><em>send-pack</em></span> on the client for pushing
data.  The protocol functions to have a server tell a client what is
currently on the server, then for the two to negotiate the smallest amount
of data to send in order to fully update one or the other.</p></div><div class="simplesect" title="pkt-line Format"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__pkt_line_format"></a>pkt-line Format</h4></div></div></div><p>The descriptions below build on the pkt-line format described in
<a class="xref" href="git-developerinfo.html#gitprotocol-common(5)" title="gitprotocol-common(5)">the section called “gitprotocol-common(5)”</a>. When the grammar indicates <span class="emphasis"><em>PKT-LINE(...)</em></span>, unless
otherwise noted the usual pkt-line LF rules apply: the sender SHOULD
include a LF, but the receiver MUST NOT complain if it is not present.</p><p>An error packet is a special pkt-line that contains an error string.</p><pre class="screen">  error-line     =  PKT-LINE("ERR" SP explanation-text)</pre><p>Throughout the protocol, where <span class="emphasis"><em>PKT-LINE(...)</em></span> is expected, an error packet MAY
be sent. Once this packet is sent by a client or a server, the data transfer
process defined in this protocol is terminated.</p></div><div class="simplesect" title="Transports"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__transports"></a>Transports</h4></div></div></div><p>There are three transports over which the packfile protocol is
initiated.  The Git transport is a simple, unauthenticated server that
takes the command (almost always <span class="emphasis"><em>upload-pack</em></span>, though Git
servers can be configured to be globally writable, in which <span class="emphasis"><em>receive-
pack</em></span> initiation is also allowed) with which the client wishes to
communicate and executes it and connects it to the requesting
process.</p><p>In the SSH transport, the client just runs the <span class="emphasis"><em>upload-pack</em></span>
or <span class="emphasis"><em>receive-pack</em></span> process on the server over the SSH protocol and then
communicates with that invoked process over the SSH connection.</p><p>The file:// transport runs the <span class="emphasis"><em>upload-pack</em></span> or <span class="emphasis"><em>receive-pack</em></span>
process locally and communicates with it over a pipe.</p></div><div class="simplesect" title="Extra Parameters"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__extra_parameters"></a>Extra Parameters</h4></div></div></div><p>The protocol provides a mechanism in which clients can send additional
information in its first message to the server. These are called "Extra
Parameters", and are supported by the Git, SSH, and HTTP protocols.</p><p>Each Extra Parameter takes the form of <span class="emphasis"><em>&lt;key&gt;=&lt;value&gt;</em></span> or <span class="emphasis"><em>&lt;key&gt;</em></span>.</p><p>Servers that receive any such Extra Parameters MUST ignore all
unrecognized keys. Currently, the only Extra Parameter recognized is
"version" with a value of <span class="emphasis"><em>1</em></span> or <span class="emphasis"><em>2</em></span>.  See <a class="xref" href="git-developerinfo.html#gitprotocol-v2(5)" title="gitprotocol-v2(5)">the section called “gitprotocol-v2(5)”</a> for more
information on protocol version 2.</p></div><div class="simplesect" title="Git Transport"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__git_transport"></a>Git Transport</h4></div></div></div><p>The Git transport starts off by sending the command and repository
on the wire using the pkt-line format, followed by a NUL byte and a
hostname parameter, terminated by a NUL byte.</p><pre class="literallayout">0033git-upload-pack /project.git\0host=myserver.com\0</pre><p>The transport may send Extra Parameters by adding an additional NUL
byte, and then adding one or more NUL-terminated strings:</p><pre class="literallayout">003egit-upload-pack /project.git\0host=myserver.com\0\0version=1\0</pre><pre class="literallayout">git-proto-request = request-command SP pathname NUL
                    [ host-parameter NUL ] [ NUL extra-parameters ]
request-command   = "git-upload-pack" / "git-receive-pack" /
                    "git-upload-archive"   ; case sensitive
pathname          = *( %x01-ff ) ; exclude NUL
host-parameter    = "host=" hostname [ ":" port ]
extra-parameters  = 1*extra-parameter
extra-parameter   = 1*( %x01-ff ) NUL</pre><p>host-parameter is used for the
git-daemon name based virtual hosting.  See --interpolated-path
option to git daemon, with the %H/%CH format characters.</p><p>Basically what the Git client is doing to connect to an <span class="emphasis"><em>upload-pack</em></span>
process on the server side over the Git protocol is this:</p><pre class="literallayout">$ echo -e -n \
  "003agit-upload-pack /schacon/gitbook.git\0host=example.com\0" |
  nc -v example.com 9418</pre></div><div class="simplesect" title="SSH Transport"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__ssh_transport"></a>SSH Transport</h4></div></div></div><p>Initiating the upload-pack or receive-pack processes over SSH is
executing the binary on the server via SSH remote execution.
It is basically equivalent to running this:</p><pre class="literallayout">$ ssh git.example.com "git-upload-pack '/project.git'"</pre><p>For a server to support Git pushing and pulling for a given user over
SSH, that user needs to be able to execute one or both of those
commands via the SSH shell that they are provided on login.  On some
systems, that shell access is limited to only being able to run those
two commands, or even just one of them.</p><p>In an ssh:// format URI, it's absolute in the URI, so the <span class="emphasis"><em>/</em></span> after
the host name (or port number) is sent as an argument, which is then
read by the remote git-upload-pack exactly as is, so it's effectively
an absolute path in the remote filesystem.</p><pre class="literallayout">   git clone ssh://user@example.com/project.git
                |
                v
ssh user@example.com "git-upload-pack '/project.git'"</pre><p>In a "user@host:path" format URI, it's relative to the user's home
directory, because the Git client will run:</p><pre class="literallayout">   git clone user@example.com:project.git
                  |
                  v
ssh user@example.com "git-upload-pack 'project.git'"</pre><p>The exception is if a <span class="emphasis"><em>~</em></span> is used, in which case
we execute it without the leading <span class="emphasis"><em>/</em></span>.</p><pre class="literallayout">   ssh://user@example.com/~alice/project.git,
                  |
                  v
ssh user@example.com "git-upload-pack '~alice/project.git'"</pre><p>Depending on the value of the <span class="emphasis"><em>protocol.version</em></span> configuration variable,
Git may attempt to send Extra Parameters as a colon-separated string in
the GIT_PROTOCOL environment variable. This is done only if
the <span class="emphasis"><em>ssh.variant</em></span> configuration variable indicates that the ssh command
supports passing environment variables as an argument.</p><p>A few things to remember here:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The "command name" is spelled with dash (e.g. git-upload-pack), but
  this can be overridden by the client;
</li><li class="listitem">
The repository path is always quoted with single quotes.
</li></ul></div></div><div class="simplesect" title="Fetching Data From a Server"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__fetching_data_from_a_server"></a>Fetching Data From a Server</h4></div></div></div><p>When one Git repository wants to get data that a second repository
has, the first can <span class="emphasis"><em>fetch</em></span> from the second.  This operation determines
what data the server has that the client does not then streams that
data down to the client in packfile format.</p></div><div class="simplesect" title="Reference Discovery"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__reference_discovery"></a>Reference Discovery</h4></div></div></div><p>When the client initially connects the server will immediately respond
with a version number (if "version=1" is sent as an Extra Parameter),
and a listing of each reference it has (all branches and tags) along
with the object name that each reference currently points to.</p><pre class="literallayout">$ echo -e -n "0045git-upload-pack /schacon/gitbook.git\0host=example.com\0\0version=1\0" |
   nc -v example.com 9418
000eversion 1
00887217a7c7e582c46cec22a130adf4b9d7d950fba0 HEAD\0multi_ack thin-pack
             side-band side-band-64k ofs-delta shallow no-progress include-tag
00441d3fcd5ced445d1abc402225c0b8a1299641f497 refs/heads/integration
003f7217a7c7e582c46cec22a130adf4b9d7d950fba0 refs/heads/master
003cb88d2441cac0977faf98efc80305012112238d9d refs/tags/v0.9
003c525128480b96c89e6418b1e40909bf6c5b2d580f refs/tags/v1.0
003fe92df48743b7bc7d26bcaabfddde0a1e20cae47c refs/tags/v1.0^{}
0000</pre><p>The returned response is a pkt-line stream describing each ref and
its current value.  The stream MUST be sorted by name according to
the C locale ordering.</p><p>If HEAD is a valid ref, HEAD MUST appear as the first advertised
ref.  If HEAD is not a valid ref, HEAD MUST NOT appear in the
advertisement list at all, but other refs may still appear.</p><p>The stream MUST include capability declarations behind a NUL on the
first ref. The peeled value of a ref (that is "ref^{}") MUST be
immediately after the ref itself, if presented. A conforming server
MUST peel the ref if it's an annotated tag.</p><pre class="screen">  advertised-refs  =  *1("version 1")
                      (no-refs / list-of-refs)
                      *shallow
                      flush-pkt

  no-refs          =  PKT-LINE(zero-id SP "capabilities^{}"
                      NUL capability-list)

  list-of-refs     =  first-ref *other-ref
  first-ref        =  PKT-LINE(obj-id SP refname
                      NUL capability-list)

  other-ref        =  PKT-LINE(other-tip / other-peeled)
  other-tip        =  obj-id SP refname
  other-peeled     =  obj-id SP refname "^{}"

  shallow          =  PKT-LINE("shallow" SP obj-id)

  capability-list  =  capability *(SP capability)
  capability       =  1*(LC_ALPHA / DIGIT / "-" / "_")
  LC_ALPHA         =  %x61-7A</pre><p>Server and client MUST use lowercase for obj-id, both MUST treat obj-id
as case-insensitive.</p><p>See protocol-capabilities.txt for a list of allowed server capabilities
and descriptions.</p></div><div class="simplesect" title="Packfile Negotiation"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__packfile_negotiation"></a>Packfile Negotiation</h4></div></div></div><p>After reference and capabilities discovery, the client can decide to
terminate the connection by sending a flush-pkt, telling the server it can
now gracefully terminate, and disconnect, when it does not need any pack
data. This can happen with the ls-remote command, and also can happen when
the client already is up to date.</p><p>Otherwise, it enters the negotiation phase, where the client and
server determine what the minimal packfile necessary for transport is,
by telling the server what objects it wants, its shallow objects
(if any), and the maximum commit depth it wants (if any).  The client
will also send a list of the capabilities it wants to be in effect,
out of what the server said it could do with the first <span class="emphasis"><em>want</em></span> line.</p><pre class="screen">  upload-request    =  want-list
                       *shallow-line
                       *1depth-request
                       [filter-request]
                       flush-pkt

  want-list         =  first-want
                       *additional-want

  shallow-line      =  PKT-LINE("shallow" SP obj-id)

  depth-request     =  PKT-LINE("deepen" SP depth) /
                       PKT-LINE("deepen-since" SP timestamp) /
                       PKT-LINE("deepen-not" SP ref)

  first-want        =  PKT-LINE("want" SP obj-id SP capability-list)
  additional-want   =  PKT-LINE("want" SP obj-id)

  depth             =  1*DIGIT

  filter-request    =  PKT-LINE("filter" SP filter-spec)</pre><p>Clients MUST send all the obj-ids it wants from the reference
discovery phase as <span class="emphasis"><em>want</em></span> lines. Clients MUST send at least one
<span class="emphasis"><em>want</em></span> command in the request body. Clients MUST NOT mention an
obj-id in a <span class="emphasis"><em>want</em></span> command which did not appear in the response
obtained through ref discovery.</p><p>The client MUST write all obj-ids which it only has shallow copies
of (meaning that it does not have the parents of a commit) as
<span class="emphasis"><em>shallow</em></span> lines so that the server is aware of the limitations of
the client's history.</p><p>The client now sends the maximum commit history depth it wants for
this transaction, which is the number of commits it wants from the
tip of the history, if any, as a <span class="emphasis"><em>deepen</em></span> line.  A depth of 0 is the
same as not making a depth request. The client does not want to receive
any commits beyond this depth, nor does it want objects needed only to
complete those commits. Commits whose parents are not received as a
result are defined as shallow and marked as such in the server. This
information is sent back to the client in the next step.</p><p>The client can optionally request that pack-objects omit various
objects from the packfile using one of several filtering techniques.
These are intended for use with partial clone and partial fetch
operations. An object that does not meet a filter-spec value is
omitted unless explicitly requested in a <span class="emphasis"><em>want</em></span> line. See <span class="emphasis"><em>rev-list</em></span>
for possible filter-spec values.</p><p>Once all the <span class="emphasis"><em>want's and 'shallow's (and optional 'deepen</em></span>) are
transferred, clients MUST send a flush-pkt, to tell the server side
that it is done sending the list.</p><p>Otherwise, if the client sent a positive depth request, the server
will determine which commits will and will not be shallow and
send this information to the client. If the client did not request
a positive depth, this step is skipped.</p><pre class="screen">  shallow-update   =  *shallow-line
                      *unshallow-line
                      flush-pkt

  shallow-line     =  PKT-LINE("shallow" SP obj-id)

  unshallow-line   =  PKT-LINE("unshallow" SP obj-id)</pre><p>If the client has requested a positive depth, the server will compute
the set of commits which are no deeper than the desired depth. The set
of commits starts at the client's wants.</p><p>The server writes <span class="emphasis"><em>shallow</em></span> lines for each
commit whose parents will not be sent as a result. The server writes
an <span class="emphasis"><em>unshallow</em></span> line for each commit which the client has indicated is
shallow, but is no longer shallow at the currently requested depth
(that is, its parents will now be sent). The server MUST NOT mark
as unshallow anything which the client has not indicated was shallow.</p><p>Now the client will send a list of the obj-ids it has using <span class="emphasis"><em>have</em></span>
lines, so the server can make a packfile that only contains the objects
that the client needs. In multi_ack mode, the canonical implementation
will send up to 32 of these at a time, then will send a flush-pkt. The
canonical implementation will skip ahead and send the next 32 immediately,
so that there is always a block of 32 "in-flight on the wire" at a time.</p><pre class="screen">  upload-haves      =  have-list
                       compute-end

  have-list         =  *have-line
  have-line         =  PKT-LINE("have" SP obj-id)
  compute-end       =  flush-pkt / PKT-LINE("done")</pre><p>If the server reads <span class="emphasis"><em>have</em></span> lines, it then will respond by ACKing any
of the obj-ids the client said it had that the server also has. The
server will ACK obj-ids differently depending on which ack mode is
chosen by the client.</p><p>In multi_ack mode:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
the server will respond with <span class="emphasis"><em>ACK obj-id continue</em></span> for any common
    commits.
</li><li class="listitem">
once the server has found an acceptable common base commit and is
    ready to make a packfile, it will blindly ACK all <span class="emphasis"><em>have</em></span> obj-ids
    back to the client.
</li><li class="listitem">
the server will then send a <span class="emphasis"><em>NAK</em></span> and then wait for another response
    from the client - either a <span class="emphasis"><em>done</em></span> or another list of <span class="emphasis"><em>have</em></span> lines.
</li></ul></div><p>In multi_ack_detailed mode:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
the server will differentiate the ACKs where it is signaling
    that it is ready to send data with <span class="emphasis"><em>ACK obj-id ready</em></span> lines, and
    signals the identified common commits with <span class="emphasis"><em>ACK obj-id common</em></span> lines.
</li></ul></div><p>Without either multi_ack or multi_ack_detailed:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
upload-pack sends "ACK obj-id" on the first common object it finds.
   After that it says nothing until the client gives it a "done".
</li><li class="listitem">
upload-pack sends "NAK" on a flush-pkt if no common object
   has been found yet.  If one has been found, and thus an ACK
   was already sent, it's silent on the flush-pkt.
</li></ul></div><p>After the client has gotten enough ACK responses that it can determine
that the server has enough information to send an efficient packfile
(in the canonical implementation, this is determined when it has received
enough ACKs that it can color everything left in the --date-order queue
as common with the server, or the --date-order queue is empty), or the
client determines that it wants to give up (in the canonical implementation,
this is determined when the client sends 256 <span class="emphasis"><em>have</em></span> lines without getting
any of them ACKed by the server - meaning there is nothing in common and
the server should just send all of its objects), then the client will send
a <span class="emphasis"><em>done</em></span> command.  The <span class="emphasis"><em>done</em></span> command signals to the server that the client
is ready to receive its packfile data.</p><p>However, the 256 limit <span class="strong"><strong>only</strong></span> turns on in the canonical client
implementation if we have received at least one "ACK %s continue"
during a prior round.  This helps to ensure that at least one common
ancestor is found before we give up entirely.</p><p>Once the <span class="emphasis"><em>done</em></span> line is read from the client, the server will either
send a final <span class="emphasis"><em>ACK obj-id</em></span> or it will send a <span class="emphasis"><em>NAK</em></span>. <span class="emphasis"><em>obj-id</em></span> is the object
name of the last commit determined to be common. The server only sends
ACK after <span class="emphasis"><em>done</em></span> if there is at least one common base and multi_ack or
multi_ack_detailed is enabled. The server always sends NAK after <span class="emphasis"><em>done</em></span>
if there is no common base found.</p><p>Instead of <span class="emphasis"><em>ACK</em></span> or <span class="emphasis"><em>NAK</em></span>, the server may send an error message (for
example, if it does not recognize an object in a <span class="emphasis"><em>want</em></span> line received
from the client).</p><p>Then the server will start sending its packfile data.</p><pre class="screen">  server-response = *ack_multi ack / nak
  ack_multi       = PKT-LINE("ACK" SP obj-id ack_status)
  ack_status      = "continue" / "common" / "ready"
  ack             = PKT-LINE("ACK" SP obj-id)
  nak             = PKT-LINE("NAK")</pre><p>A simple clone may look like this (with no <span class="emphasis"><em>have</em></span> lines):</p><pre class="screen">   C: 0054want 74730d410fcb6603ace96f1dc55ea6196122532d multi_ack \
     side-band-64k ofs-delta\n
   C: 0032want 7d1665144a3a975c05f1f43902ddaf084e784dbe\n
   C: 0032want 5a3f6be755bbb7deae50065988cbfa1ffa9ab68a\n
   C: 0032want 7e47fe2bd8d01d481f44d7af0531bd93d3b21c01\n
   C: 0032want 74730d410fcb6603ace96f1dc55ea6196122532d\n
   C: 0000
   C: 0009done\n

   S: 0008NAK\n
   S: [PACKFILE]</pre><p>An incremental update (fetch) response might look like this:</p><pre class="screen">   C: 0054want 74730d410fcb6603ace96f1dc55ea6196122532d multi_ack \
     side-band-64k ofs-delta\n
   C: 0032want 7d1665144a3a975c05f1f43902ddaf084e784dbe\n
   C: 0032want 5a3f6be755bbb7deae50065988cbfa1ffa9ab68a\n
   C: 0000
   C: 0032have 7e47fe2bd8d01d481f44d7af0531bd93d3b21c01\n
   C: [30 more have lines]
   C: 0032have 74730d410fcb6603ace96f1dc55ea6196122532d\n
   C: 0000

   S: 003aACK 7e47fe2bd8d01d481f44d7af0531bd93d3b21c01 continue\n
   S: 003aACK 74730d410fcb6603ace96f1dc55ea6196122532d continue\n
   S: 0008NAK\n

   C: 0009done\n

   S: 0031ACK 74730d410fcb6603ace96f1dc55ea6196122532d\n
   S: [PACKFILE]</pre></div><div class="simplesect" title="Packfile Data"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__packfile_data"></a>Packfile Data</h4></div></div></div><p>Now that the client and server have finished negotiation about what
the minimal amount of data that needs to be sent to the client is, the server
will construct and send the required data in packfile format.</p><p>See <a class="xref" href="git-developerinfo.html#gitformat-pack(5)" title="gitformat-pack(5)">the section called “gitformat-pack(5)”</a> for what the packfile itself actually looks like.</p><p>If <span class="emphasis"><em>side-band</em></span> or <span class="emphasis"><em>side-band-64k</em></span> capabilities have been specified by
the client, the server will send the packfile data multiplexed.</p><p>Each packet starting with the packet-line length of the amount of data
that follows, followed by a single byte specifying the sideband the
following data is coming in on.</p><p>In <span class="emphasis"><em>side-band</em></span> mode, it will send up to 999 data bytes plus 1 control
code, for a total of up to 1000 bytes in a pkt-line.  In <span class="emphasis"><em>side-band-64k</em></span>
mode it will send up to 65519 data bytes plus 1 control code, for a
total of up to 65520 bytes in a pkt-line.</p><p>The sideband byte will be a <span class="emphasis"><em>1</em></span>, <span class="emphasis"><em>2</em></span> or a <span class="emphasis"><em>3</em></span>. Sideband <span class="emphasis"><em>1</em></span> will contain
packfile data, sideband <span class="emphasis"><em>2</em></span> will be used for progress information that the
client will generally print to stderr and sideband <span class="emphasis"><em>3</em></span> is used for error
information.</p><p>If no <span class="emphasis"><em>side-band</em></span> capability was specified, the server will stream the
entire packfile without multiplexing.</p></div><div class="simplesect" title="Pushing Data To a Server"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__pushing_data_to_a_server"></a>Pushing Data To a Server</h4></div></div></div><p>Pushing data to a server will invoke the <span class="emphasis"><em>receive-pack</em></span> process on the
server, which will allow the client to tell it which references it should
update and then send all the data the server will need for those new
references to be complete.  Once all the data is received and validated,
the server will then update its references to what the client specified.</p></div><div class="simplesect" title="Authentication"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__authentication"></a>Authentication</h4></div></div></div><p>The protocol itself contains no authentication mechanisms.  That is to be
handled by the transport, such as SSH, before the <span class="emphasis"><em>receive-pack</em></span> process is
invoked.  If <span class="emphasis"><em>receive-pack</em></span> is configured over the Git transport, those
repositories will be writable by anyone who can access that port (9418) as
that transport is unauthenticated.</p></div><div class="simplesect" title="Reference Discovery"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__reference_discovery_2"></a>Reference Discovery</h4></div></div></div><p>The reference discovery phase is done nearly the same way as it is in the
fetching protocol. Each reference obj-id and name on the server is sent
in packet-line format to the client, followed by a flush-pkt.  The only
real difference is that the capability listing is different - the only
possible values are <span class="emphasis"><em>report-status</em></span>, <span class="emphasis"><em>report-status-v2</em></span>, <span class="emphasis"><em>delete-refs</em></span>,
<span class="emphasis"><em>ofs-delta</em></span>, <span class="emphasis"><em>atomic</em></span> and <span class="emphasis"><em>push-options</em></span>.</p></div><div class="simplesect" title="Reference Update Request and Packfile Transfer"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__reference_update_request_and_packfile_transfer"></a>Reference Update Request and Packfile Transfer</h4></div></div></div><p>Once the client knows what references the server is at, it can send a
list of reference update requests.  For each reference on the server
that it wants to update, it sends a line listing the obj-id currently on
the server, the obj-id the client would like to update it to and the name
of the reference.</p><p>This list is followed by a flush-pkt.</p><pre class="screen">  update-requests   =  *shallow ( command-list | push-cert )

  shallow           =  PKT-LINE("shallow" SP obj-id)

  command-list      =  PKT-LINE(command NUL capability-list)
                       *PKT-LINE(command)
                       flush-pkt

  command           =  create / delete / update
  create            =  zero-id SP new-id  SP name
  delete            =  old-id  SP zero-id SP name
  update            =  old-id  SP new-id  SP name

  old-id            =  obj-id
  new-id            =  obj-id

  push-cert         = PKT-LINE("push-cert" NUL capability-list LF)
                      PKT-LINE("certificate version 0.1" LF)
                      PKT-LINE("pusher" SP ident LF)
                      PKT-LINE("pushee" SP url LF)
                      PKT-LINE("nonce" SP nonce LF)
                      *PKT-LINE("push-option" SP push-option LF)
                      PKT-LINE(LF)
                      *PKT-LINE(command LF)
                      *PKT-LINE(gpg-signature-lines LF)
                      PKT-LINE("push-cert-end" LF)

  push-option       =  1*( VCHAR | SP )</pre><p>If the server has advertised the <span class="emphasis"><em>push-options</em></span> capability and the client has
specified <span class="emphasis"><em>push-options</em></span> as part of the capability list above, the client then
sends its push options followed by a flush-pkt.</p><pre class="screen">  push-options      =  *PKT-LINE(push-option) flush-pkt</pre><p>For backwards compatibility with older Git servers, if the client sends a push
cert and push options, it MUST send its push options both embedded within the
push cert and after the push cert. (Note that the push options within the cert
are prefixed, but the push options after the cert are not.) Both these lists
MUST be the same, modulo the prefix.</p><p>After that the packfile that
should contain all the objects that the server will need to complete the new
references will be sent.</p><pre class="screen">  packfile          =  "PACK" 28*(OCTET)</pre><p>If the receiving end does not support delete-refs, the sending end MUST
NOT ask for delete command.</p><p>If the receiving end does not support push-cert, the sending end
MUST NOT send a push-cert command.  When a push-cert command is
sent, command-list MUST NOT be sent; the commands recorded in the
push certificate is used instead.</p><p>The packfile MUST NOT be sent if the only command used is <span class="emphasis"><em>delete</em></span>.</p><p>A packfile MUST be sent if either create or update command is used,
even if the server already has all the necessary objects.  In this
case the client MUST send an empty packfile.   The only time this
is likely to happen is if the client is creating
a new branch or a tag that points to an existing obj-id.</p><p>The server will receive the packfile, unpack it, then validate each
reference that is being updated that it hasn't changed while the request
was being processed (the obj-id is still the same as the old-id), and
it will run any update hooks to make sure that the update is acceptable.
If all of that is fine, the server will then update the references.</p></div><div class="simplesect" title="Push Certificate"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__push_certificate"></a>Push Certificate</h4></div></div></div><p>A push certificate begins with a set of header lines.  After the
header and an empty line, the protocol commands follow, one per
line. Note that the trailing LF in push-cert PKT-LINEs is <span class="emphasis"><em>not</em></span>
optional; it must be present.</p><p>Currently, the following header fields are defined:</p><div class="variablelist"><dl><dt><span class="term">
<span class="emphasis"><em>pusher</em></span> ident
</span></dt><dd>
        Identify the GPG key in "Human Readable Name &lt;<a class="ulink" href="mailto:email@address" target="_blank">email@address</a>&gt;"
        format.
</dd><dt><span class="term">
<span class="emphasis"><em>pushee</em></span> url
</span></dt><dd>
        The repository URL (anonymized, if the URL contains
        authentication material) the user who ran <span class="emphasis"><em>git push</em></span>
        intended to push into.
</dd><dt><span class="term">
<span class="emphasis"><em>nonce</em></span> nonce
</span></dt><dd>
        The <span class="emphasis"><em>nonce</em></span> string the receiving repository asked the
        pushing user to include in the certificate, to prevent
        replay attacks.
</dd></dl></div><p>The GPG signature lines are a detached signature for the contents
recorded in the push certificate before the signature block begins.
The detached signature is used to certify that the commands were
given by the pusher, who must be the signer.</p></div><div class="simplesect" title="Report Status"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__report_status"></a>Report Status</h4></div></div></div><p>After receiving the pack data from the sender, the receiver sends a
report if <span class="emphasis"><em>report-status</em></span> or <span class="emphasis"><em>report-status-v2</em></span> capability is in effect.
It is a short listing of what happened in that update.  It will first
list the status of the packfile unpacking as either <span class="emphasis"><em>unpack ok</em></span> or
<span class="emphasis"><em>unpack [error]</em></span>.  Then it will list the status for each of the references
that it tried to update.  Each line is either <span class="emphasis"><em>ok [refname]</em></span> if the
update was successful, or <span class="emphasis"><em>ng [refname] [error]</em></span> if the update was not.</p><pre class="screen">  report-status     = unpack-status
                      1*(command-status)
                      flush-pkt

  unpack-status     = PKT-LINE("unpack" SP unpack-result)
  unpack-result     = "ok" / error-msg

  command-status    = command-ok / command-fail
  command-ok        = PKT-LINE("ok" SP refname)
  command-fail      = PKT-LINE("ng" SP refname SP error-msg)

  error-msg         = 1*(OCTET) ; where not "ok"</pre><p>The <span class="emphasis"><em>report-status-v2</em></span> capability extends the protocol by adding new option
lines in order to support reporting of reference rewritten by the
<span class="emphasis"><em>proc-receive</em></span> hook.  The <span class="emphasis"><em>proc-receive</em></span> hook may handle a command for a
pseudo-reference which may create or update one or more references, and each
reference may have different name, different new-oid, and different old-oid.</p><pre class="screen">  report-status-v2  = unpack-status
                      1*(command-status-v2)
                      flush-pkt

  unpack-status     = PKT-LINE("unpack" SP unpack-result)
  unpack-result     = "ok" / error-msg

  command-status-v2 = command-ok-v2 / command-fail
  command-ok-v2     = command-ok
                      *option-line

  command-ok        = PKT-LINE("ok" SP refname)
  command-fail      = PKT-LINE("ng" SP refname SP error-msg)

  error-msg         = 1*(OCTET) ; where not "ok"

  option-line       = *1(option-refname)
                      *1(option-old-oid)
                      *1(option-new-oid)
                      *1(option-forced-update)

  option-refname    = PKT-LINE("option" SP "refname" SP refname)
  option-old-oid    = PKT-LINE("option" SP "old-oid" SP obj-id)
  option-new-oid    = PKT-LINE("option" SP "new-oid" SP obj-id)
  option-force      = PKT-LINE("option" SP "forced-update")</pre><p>Updates can be unsuccessful for a number of reasons.  The reference can have
changed since the reference discovery phase was originally sent, meaning
someone pushed in the meantime.  The reference being pushed could be a
non-fast-forward reference and the update hooks or configuration could be
set to not allow that, etc.  Also, some references can be updated while others
can be rejected.</p><p>An example client/server communication might look like this:</p><pre class="screen">   S: 006274730d410fcb6603ace96f1dc55ea6196122532d refs/heads/local\0report-status delete-refs ofs-delta\n
   S: 003e7d1665144a3a975c05f1f43902ddaf084e784dbe refs/heads/debug\n
   S: 003f74730d410fcb6603ace96f1dc55ea6196122532d refs/heads/master\n
   S: 003d74730d410fcb6603ace96f1dc55ea6196122532d refs/heads/team\n
   S: 0000

   C: 00677d1665144a3a975c05f1f43902ddaf084e784dbe 74730d410fcb6603ace96f1dc55ea6196122532d refs/heads/debug\n
   C: 006874730d410fcb6603ace96f1dc55ea6196122532d 5a3f6be755bbb7deae50065988cbfa1ffa9ab68a refs/heads/master\n
   C: 0000
   C: [PACKDATA]

   S: 000eunpack ok\n
   S: 0018ok refs/heads/debug\n
   S: 002ang refs/heads/master non-fast-forward\n</pre></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-pack(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div><div lang="en" class="sect2" title="gitprotocol-v2(5)"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-v2(5)"></a>gitprotocol-v2(5)</h3></div></div></div><a class="indexterm" name="id1554238"></a><div class="simplesect" title="NAME"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-v2(5)__name"></a>NAME</h4></div></div></div><p>gitprotocol-v2 - Git Wire Protocol, Version 2</p></div><div class="simplesect" title="SYNOPSIS"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-v2(5)__synopsis"></a>SYNOPSIS</h4></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="literallayout"><p>&lt;over-the-wire-protocol&gt;</p></div></blockquote></div></div><div class="simplesect" title="DESCRIPTION"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-v2(5)__description"></a>DESCRIPTION</h4></div></div></div><p>This document presents a specification for a version 2 of Git's wire
protocol.  Protocol v2 will improve upon v1 in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Instead of multiple service names, multiple commands will be
    supported by a single service
</li><li class="listitem">
Easily extendable as capabilities are moved into their own section
    of the protocol, no longer being hidden behind a NUL byte and
    limited by the size of a pkt-line
</li><li class="listitem">
Separate out other information hidden behind NUL bytes (e.g. agent
    string as a capability and symrefs can be requested using <span class="emphasis"><em>ls-refs</em></span>)
</li><li class="listitem">
Reference advertisement will be omitted unless explicitly requested
</li><li class="listitem">
ls-refs command to explicitly request some refs
</li><li class="listitem">
Designed with http and stateless-rpc in mind.  With clear flush
    semantics the http remote helper can simply act as a proxy
</li></ul></div><p>In protocol v2 communication is command oriented.  When first contacting a
server a list of capabilities will be advertised.  Some of these capabilities
will be commands which a client can request be executed.  Once a command
has completed, a client can reuse the connection and request that other
commands be executed.</p></div><div class="simplesect" title="Packet-Line Framing"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-v2(5)__packet_line_framing"></a>Packet-Line Framing</h4></div></div></div><p>All communication is done using packet-line framing, just as in v1.  See
<a class="xref" href="git-developerinfo.html#gitprotocol-pack(5)" title="gitprotocol-pack(5)">the section called “gitprotocol-pack(5)”</a> and <a class="xref" href="git-developerinfo.html#gitprotocol-common(5)" title="gitprotocol-common(5)">the section called “gitprotocol-common(5)”</a> for more information.</p><p>In protocol v2 these special packets will have the following semantics:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<span class="emphasis"><em>0000</em></span> Flush Packet (flush-pkt) - indicates the end of a message
</li><li class="listitem">
<span class="emphasis"><em>0001</em></span> Delimiter Packet (delim-pkt) - separates sections of a message
</li><li class="listitem">
<span class="emphasis"><em>0002</em></span> Response End Packet (response-end-pkt) - indicates the end of a
    response for stateless connections
</li></ul></div></div><div class="simplesect" title="Initial Client Request"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-v2(5)__initial_client_request"></a>Initial Client Request</h4></div></div></div><p>In general a client can request to speak protocol v2 by sending
<span class="emphasis"><em>version=2</em></span> through the respective side-channel for the transport being
used which inevitably sets <span class="emphasis"><em>GIT_PROTOCOL</em></span>.  More information can be
found in <a class="xref" href="git-developerinfo.html#gitprotocol-pack(5)" title="gitprotocol-pack(5)">the section called “gitprotocol-pack(5)”</a> and <a class="xref" href="git-developerinfo.html#gitprotocol-http(5)" title="gitprotocol-http(5)">the section called “gitprotocol-http(5)”</a>, as well as the
<span class="emphasis"><em>GIT_PROTOCOL</em></span> definition in <span class="emphasis"><em>git.txt</em></span>. In all cases the
response from the server is the capability advertisement.</p><div class="section" title="Git Transport"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__git_transport"></a>Git Transport</h2></div></div></div><p>When using the git:// transport, you can request to use protocol v2 by
sending "version=2" as an extra parameter:</p><pre class="literallayout">003egit-upload-pack /project.git\0host=myserver.com\0\0version=2\0</pre></div><div class="section" title="SSH and File Transport"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__ssh_and_file_transport"></a>SSH and File Transport</h2></div></div></div><p>When using either the ssh:// or file:// transport, the GIT_PROTOCOL
environment variable must be set explicitly to include "version=2".
The server may need to be configured to allow this environment variable
to pass.</p></div><div class="section" title="HTTP Transport"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__http_transport"></a>HTTP Transport</h2></div></div></div><p>When using the http:// or https:// transport a client makes a "smart"
info/refs request as described in <a class="xref" href="git-developerinfo.html#gitprotocol-http(5)" title="gitprotocol-http(5)">the section called “gitprotocol-http(5)”</a> and requests that
v2 be used by supplying "version=2" in the <span class="emphasis"><em>Git-Protocol</em></span> header.</p><pre class="literallayout">C: GET $GIT_URL/info/refs?service=git-upload-pack HTTP/1.0
C: Git-Protocol: version=2</pre><p>A v2 server would reply:</p><pre class="literallayout">S: 200 OK
S: &lt;Some headers&gt;
S: ...
S:
S: 000eversion 2\n
S: &lt;capability-advertisement&gt;</pre><p>Subsequent requests are then made directly to the service
<span class="emphasis"><em>$GIT_URL/git-upload-pack</em></span>. (This works the same for git-receive-pack).</p><p>Uses the <span class="emphasis"><em>--http-backend-info-refs</em></span> option to
<a class="xref" href="git-command.html#git-upload-pack(1)" title="git-upload-pack(1)">the section called “git-upload-pack(1)”</a>.</p><p>The server may need to be configured to pass this header's contents via
the <span class="emphasis"><em>GIT_PROTOCOL</em></span> variable. See the discussion in <span class="emphasis"><em>git-http-backend.txt</em></span>.</p></div></div><div class="simplesect" title="Capability Advertisement"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-v2(5)__capability_advertisement"></a>Capability Advertisement</h4></div></div></div><p>A server which decides to communicate (based on a request from a client)
using protocol version 2, notifies the client by sending a version string
in its initial response followed by an advertisement of its capabilities.
Each capability is a key with an optional value.  Clients must ignore all
unknown keys.  Semantics of unknown values are left to the definition of
each key.  Some capabilities will describe commands which can be requested
to be executed by the client.</p><pre class="literallayout">capability-advertisement = protocol-version
                           capability-list
                           flush-pkt</pre><pre class="literallayout">protocol-version = PKT-LINE("version 2" LF)
capability-list = *capability
capability = PKT-LINE(key[=value] LF)</pre><pre class="literallayout">key = 1*(ALPHA | DIGIT | "-_")
value = 1*(ALPHA | DIGIT | " -_.,?\/{}[]()&lt;&gt;!@#$%^&amp;*+=:;")</pre></div><div class="simplesect" title="Command Request"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-v2(5)__command_request"></a>Command Request</h4></div></div></div><p>After receiving the capability advertisement, a client can then issue a
request to select the command it wants with any particular capabilities
or arguments.  There is then an optional section where the client can
provide any command specific parameters or queries.  Only a single
command can be requested at a time.</p><pre class="literallayout">request = empty-request | command-request
empty-request = flush-pkt
command-request = command
                  capability-list
                  delim-pkt
                  command-args
                  flush-pkt
command = PKT-LINE("command=" key LF)
command-args = *command-specific-arg</pre><pre class="literallayout">command-specific-args are packet line framed arguments defined by
each individual command.</pre><p>The server will then check to ensure that the client's request is
comprised of a valid command as well as valid capabilities which were
advertised.  If the request is valid the server will then execute the
command.  A server MUST wait till it has received the client's entire
request before issuing a response.  The format of the response is
determined by the command being executed, but in all cases a flush-pkt
indicates the end of the response.</p><p>When a command has finished, and the client has received the entire
response from the server, a client can either request that another
command be executed or can terminate the connection.  A client may
optionally send an empty request consisting of just a flush-pkt to
indicate that no more requests will be made.</p></div><div class="simplesect" title="Capabilities"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-v2(5)__capabilities"></a>Capabilities</h4></div></div></div><p>There are two different types of capabilities: normal capabilities,
which can be used to convey information or alter the behavior of a
request, and commands, which are the core actions that a client wants to
perform (fetch, push, etc).</p><p>Protocol version 2 is stateless by default.  This means that all commands
must only last a single round and be stateless from the perspective of the
server side, unless the client has requested a capability indicating that
state should be maintained by the server.  Clients MUST NOT require state
management on the server side in order to function correctly.  This
permits simple round-robin load-balancing on the server side, without
needing to worry about state management.</p><div class="section" title="agent"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__agent"></a>agent</h2></div></div></div><p>The server can advertise the <span class="emphasis"><em>agent</em></span> capability with a value <span class="emphasis"><em>X</em></span> (in the
form <span class="emphasis"><em>agent=X</em></span>) to notify the client that the server is running version
<span class="emphasis"><em>X</em></span>.  The client may optionally send its own agent string by including
the <span class="emphasis"><em>agent</em></span> capability with a value <span class="emphasis"><em>Y</em></span> (in the form <span class="emphasis"><em>agent=Y</em></span>) in its
request to the server (but it MUST NOT do so if the server did not
advertise the agent capability). The <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> strings may contain any
printable ASCII characters except space (i.e., the byte range 33 ⇐ x ⇐
126), and are typically of the form "package/version-os" (e.g.,
"git/1.8.3.1-Linux") where <span class="emphasis"><em>os</em></span> is the operating system name (e.g.,
"Linux"). <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> can be configured using the GIT_USER_AGENT
environment variable and it takes priority. The <span class="emphasis"><em>os</em></span> is
retrieved using the <span class="emphasis"><em>sysname</em></span> field of the <span class="emphasis"><em>uname(2)</em></span> system call
or its equivalent. The agent strings are purely informative for statistics
and debugging purposes, and MUST NOT be used to programmatically assume
the presence or absence of particular features.</p></div><div class="section" title="ls-refs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__ls_refs"></a>ls-refs</h2></div></div></div><p><span class="emphasis"><em>ls-refs</em></span> is the command used to request a reference advertisement in v2.
Unlike the current reference advertisement, ls-refs takes in arguments
which can be used to limit the refs sent from the server.</p><p>Additional features not supported in the base command will be advertised
as the value of the command in the capability advertisement in the form
of a space separated list of features: "&lt;command&gt;=&lt;feature-1&gt; &lt;feature-2&gt;"</p><p>ls-refs takes in the following arguments:</p><pre class="literallayout">symrefs
    In addition to the object pointed by it, show the underlying ref
    pointed by it when showing a symbolic ref.
peel
    Show peeled tags.
ref-prefix &lt;prefix&gt;
    When specified, only references having a prefix matching one of
    the provided prefixes are displayed. Multiple instances may be
    given, in which case references matching any prefix will be
    shown. Note that this is purely for optimization; a server MAY
    show refs not matching the prefix if it chooses, and clients
    should filter the result themselves.</pre><p>If the <span class="emphasis"><em>unborn</em></span> feature is advertised the following argument can be
included in the client's request.</p><pre class="literallayout">unborn
    The server will send information about HEAD even if it is a symref
    pointing to an unborn branch in the form "unborn HEAD
    symref-target:&lt;target&gt;".</pre><p>The output of ls-refs is as follows:</p><pre class="literallayout">output = *ref
         flush-pkt
obj-id-or-unborn = (obj-id | "unborn")
ref = PKT-LINE(obj-id-or-unborn SP refname *(SP ref-attribute) LF)
ref-attribute = (symref | peeled)
symref = "symref-target:" symref-target
peeled = "peeled:" obj-id</pre></div><div class="section" title="fetch"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__fetch"></a>fetch</h2></div></div></div><p><span class="emphasis"><em>fetch</em></span> is the command used to fetch a packfile in v2.  It can be looked
at as a modified version of the v1 fetch where the ref-advertisement is
stripped out (since the <span class="emphasis"><em>ls-refs</em></span> command fills that role) and the
message format is tweaked to eliminate redundancies and permit easy
addition of future extensions.</p><p>Additional features not supported in the base command will be advertised
as the value of the command in the capability advertisement in the form
of a space separated list of features: "&lt;command&gt;=&lt;feature-1&gt; &lt;feature-2&gt;"</p><p>A <span class="emphasis"><em>fetch</em></span> request can take the following arguments:</p><pre class="literallayout">want &lt;oid&gt;
    Indicates to the server an object which the client wants to
    retrieve.  Wants can be anything and are not limited to
    advertised objects.</pre><pre class="literallayout">have &lt;oid&gt;
    Indicates to the server an object which the client has locally.
    This allows the server to make a packfile which only contains
    the objects that the client needs. Multiple 'have' lines can be
    supplied.</pre><pre class="literallayout">done
    Indicates to the server that negotiation should terminate (or
    not even begin if performing a clone) and that the server should
    use the information supplied in the request to construct the
    packfile.</pre><pre class="literallayout">thin-pack
    Request that a thin pack be sent, which is a pack with deltas
    which reference base objects not contained within the pack (but
    are known to exist at the receiving end). This can reduce the
    network traffic significantly, but it requires the receiving end
    to know how to "thicken" these packs by adding the missing bases
    to the pack.</pre><pre class="literallayout">no-progress
    Request that progress information that would normally be sent on
    side-band channel 2, during the packfile transfer, should not be
    sent.  However, the side-band channel 3 is still used for error
    responses.</pre><pre class="literallayout">include-tag
    Request that annotated tags should be sent if the objects they
    point to are being sent.</pre><pre class="literallayout">ofs-delta
    Indicate that the client understands PACKv2 with delta referring
    to its base by position in pack rather than by an oid.  That is,
    they can read OBJ_OFS_DELTA (aka type 6) in a packfile.</pre><p>If the <span class="emphasis"><em>shallow</em></span> feature is advertised the following arguments can be
included in the clients request as well as the potential addition of the
<span class="emphasis"><em>shallow-info</em></span> section in the server's response as explained below.</p><pre class="literallayout">shallow &lt;oid&gt;
    A client must notify the server of all commits for which it only
    has shallow copies (meaning that it doesn't have the parents of
    a commit) by supplying a 'shallow &lt;oid&gt;' line for each such
    object so that the server is aware of the limitations of the
    client's history.  This is so that the server is aware that the
    client may not have all objects reachable from such commits.</pre><pre class="literallayout">deepen &lt;depth&gt;
    Requests that the fetch/clone should be shallow having a commit
    depth of &lt;depth&gt; relative to the remote side.</pre><pre class="literallayout">deepen-relative
    Requests that the semantics of the "deepen" command be changed
    to indicate that the depth requested is relative to the client's
    current shallow boundary, instead of relative to the requested
    commits.</pre><pre class="literallayout">deepen-since &lt;timestamp&gt;
    Requests that the shallow clone/fetch should be cut at a
    specific time, instead of depth.  Internally it's equivalent to
    doing "git rev-list --max-age=&lt;timestamp&gt;". Cannot be used with
    "deepen".</pre><pre class="literallayout">deepen-not &lt;rev&gt;
    Requests that the shallow clone/fetch should be cut at a
    specific revision specified by '&lt;rev&gt;', instead of a depth.
    Internally it's equivalent of doing "git rev-list --not &lt;rev&gt;".
    Cannot be used with "deepen", but can be used with
    "deepen-since".</pre><p>If the <span class="emphasis"><em>filter</em></span> feature is advertised, the following argument can be
included in the client's request:</p><pre class="literallayout">filter &lt;filter-spec&gt;
    Request that various objects from the packfile be omitted
    using one of several filtering techniques. These are intended
    for use with partial clone and partial fetch operations. See
    `rev-list` for possible "filter-spec" values. When communicating
    with other processes, senders SHOULD translate scaled integers
    (e.g. "1k") into a fully-expanded form (e.g. "1024") to aid
    interoperability with older receivers that may not understand
    newly-invented scaling suffixes. However, receivers SHOULD
    accept the following suffixes: 'k', 'm', and 'g' for 1024,
    1048576, and 1073741824, respectively.</pre><p>If the <span class="emphasis"><em>ref-in-want</em></span> feature is advertised, the following argument can
be included in the client's request as well as the potential addition of
the <span class="emphasis"><em>wanted-refs</em></span> section in the server's response as explained below.</p><pre class="literallayout">want-ref &lt;ref&gt;
    Indicates to the server that the client wants to retrieve a
    particular ref, where &lt;ref&gt; is the full name of a ref on the
    server.  It is a protocol error to send want-ref for the
    same ref more than once.</pre><p>If the <span class="emphasis"><em>sideband-all</em></span> feature is advertised, the following argument can be
included in the client's request:</p><pre class="literallayout">sideband-all
    Instruct the server to send the whole response multiplexed, not just
    the packfile section. All non-flush and non-delim PKT-LINE in the
    response (not only in the packfile section) will then start with a byte
    indicating its sideband (1, 2, or 3), and the server may send "0005\2"
    (a PKT-LINE of sideband 2 with no payload) as a keepalive packet.</pre><p>If the <span class="emphasis"><em>packfile-uris</em></span> feature is advertised, the following argument
can be included in the client's request as well as the potential
addition of the <span class="emphasis"><em>packfile-uris</em></span> section in the server's response as
explained below. Note that at most one <span class="emphasis"><em>packfile-uris</em></span> line can be sent
to the server.</p><pre class="literallayout">packfile-uris &lt;comma-separated-list-of-protocols&gt;
    Indicates to the server that the client is willing to receive
    URIs of any of the given protocols in place of objects in the
    sent packfile. Before performing the connectivity check, the
    client should download from all given URIs. Currently, the
    protocols supported are "http" and "https".</pre><p>If the <span class="emphasis"><em>wait-for-done</em></span> feature is advertised, the following argument
can be included in the client's request.</p><pre class="literallayout">wait-for-done
    Indicates to the server that it should never send "ready", but
    should wait for the client to say "done" before sending the
    packfile.</pre><p>The response of <span class="emphasis"><em>fetch</em></span> is broken into a number of sections separated by
delimiter packets (0001), with each section beginning with its section
header. Most sections are sent only when the packfile is sent.</p><pre class="literallayout">output = acknowledgements flush-pkt |
         [acknowledgments delim-pkt] [shallow-info delim-pkt]
         [wanted-refs delim-pkt] [packfile-uris delim-pkt]
         packfile flush-pkt</pre><pre class="literallayout">acknowledgments = PKT-LINE("acknowledgments" LF)
                  (nak | *ack)
                  (ready)
ready = PKT-LINE("ready" LF)
nak = PKT-LINE("NAK" LF)
ack = PKT-LINE("ACK" SP obj-id LF)</pre><pre class="literallayout">shallow-info = PKT-LINE("shallow-info" LF)
               *PKT-LINE((shallow | unshallow) LF)
shallow = "shallow" SP obj-id
unshallow = "unshallow" SP obj-id</pre><pre class="literallayout">wanted-refs = PKT-LINE("wanted-refs" LF)
              *PKT-LINE(wanted-ref LF)
wanted-ref = obj-id SP refname</pre><pre class="literallayout">packfile-uris = PKT-LINE("packfile-uris" LF) *packfile-uri
packfile-uri = PKT-LINE(40*(HEXDIGIT) SP *%x20-ff LF)</pre><pre class="literallayout">packfile = PKT-LINE("packfile" LF)
           *PKT-LINE(%x01-03 *%x00-ff)</pre><pre class="literallayout">acknowledgments section
    * If the client determines that it is finished with negotiations by
      sending a "done" line (thus requiring the server to send a packfile),
      the acknowledgments sections MUST be omitted from the server's
      response.</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Always begins with the section header "acknowledgments"
</li><li class="listitem">
The server will respond with "NAK" if none of the object ids sent
          as have lines were common.
</li><li class="listitem">
The server will respond with "ACK obj-id" for all of the
          object ids sent as have lines which are common.
</li><li class="listitem">
A response cannot have both "ACK" lines as well as a "NAK"
          line.
</li><li class="listitem">
The server will respond with a "ready" line indicating that
          the server has found an acceptable common base and is ready to
          make and send a packfile (which will be found in the packfile
          section of the same response)
</li><li class="listitem"><p class="simpara">
If the server has found a suitable cut point and has decided
          to send a "ready" line, then the server can decide to (as an
          optimization) omit any "ACK" lines it would have sent during
          its response.  This is because the server will have already
          determined the objects it plans to send to the client and no
          further negotiation is needed.
</p><pre class="literallayout">shallow-info section
    * If the client has requested a shallow fetch/clone, a shallow
      client requests a fetch or the server is shallow then the
      server's response may include a shallow-info section.  The
      shallow-info section will be included if (due to one of the
      above conditions) the server needs to inform the client of any
      shallow boundaries or adjustments to the clients already
      existing shallow boundaries.</pre></li><li class="listitem">
Always begins with the section header "shallow-info"
</li><li class="listitem">
If a positive depth is requested, the server will compute the
          set of commits which are no deeper than the desired depth.
</li><li class="listitem">
The server sends a "shallow obj-id" line for each commit whose
          parents will not be sent in the following packfile.
</li><li class="listitem">
The server sends an "unshallow obj-id" line for each commit
          which the client has indicated is shallow, but is no longer
          shallow as a result of the fetch (due to its parents being
          sent in the following packfile).
</li><li class="listitem"><p class="simpara">
The server MUST NOT send any "unshallow" lines for anything
          which the client has not indicated was shallow as a part of
          its request.
</p><pre class="literallayout">wanted-refs section
    * This section is only included if the client has requested a
      ref using a 'want-ref' line and if a packfile section is also
      included in the response.</pre></li><li class="listitem">
Always begins with the section header "wanted-refs".
</li><li class="listitem">
The server will send a ref listing ("&lt;oid&gt; &lt;refname&gt;") for
          each reference requested using <span class="emphasis"><em>want-ref</em></span> lines.
</li><li class="listitem"><p class="simpara">
The server MUST NOT send any refs which were not requested
          using <span class="emphasis"><em>want-ref</em></span> lines.
</p><pre class="literallayout">packfile-uris section
    * This section is only included if the client sent
      'packfile-uris' and the server has at least one such URI to
      send.</pre></li><li class="listitem">
Always begins with the section header "packfile-uris".
</li><li class="listitem">
For each URI the server sends, it sends a hash of the pack's
          contents (as output by git index-pack) followed by the URI.
</li><li class="listitem"><p class="simpara">
The hashes are 40 hex characters long. When Git upgrades to a new
          hash algorithm, this might need to be updated. (It should match
          whatever index-pack outputs after "pack\t" or "keep\t".
</p><pre class="literallayout">packfile section
    * This section is only included if the client has sent 'want'
      lines in its request and either requested that no more
      negotiation be done by sending 'done' or if the server has
      decided it has found a sufficient cut point to produce a
      packfile.</pre></li><li class="listitem">
Always begins with the section header "packfile"
</li><li class="listitem">
The transmission of the packfile begins immediately after the
          section header
</li><li class="listitem"><p class="simpara">
The data transfer of the packfile is always multiplexed, using
          the same semantics of the <span class="emphasis"><em>side-band-64k</em></span> capability from
          protocol version 1.  This means that each packet, during the
          packfile data stream, is made up of a leading 4-byte pkt-line
          length (typical of the pkt-line format), followed by a 1-byte
          stream code, followed by the actual data.
</p><pre class="literallayout">The stream code can be one of:
      1 - pack data
      2 - progress messages
      3 - fatal error message just before stream aborts</pre></li></ul></div></div><div class="section" title="server-option"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__server_option"></a>server-option</h2></div></div></div><p>If advertised, indicates that any number of server specific options can be
included in a request.  This is done by sending each option as a
"server-option=&lt;option&gt;" capability line in the capability-list section of
a request.</p><p>The provided options must not contain a NUL or LF character.</p></div><div class="section" title="object-format"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__object_format"></a>object-format</h2></div></div></div><p>The server can advertise the <span class="emphasis"><em>object-format</em></span> capability with a value <span class="emphasis"><em>X</em></span> (in the
form <span class="emphasis"><em>object-format=X</em></span>) to notify the client that the server is able to deal
with objects using hash algorithm X.  If not specified, the server is assumed to
only handle SHA-1.  If the client would like to use a hash algorithm other than
SHA-1, it should specify its object-format string.</p></div><div class="section" title="session-id=&lt;session-id&gt;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__session_id_lt_session_id_gt"></a>session-id=&lt;session-id&gt;</h2></div></div></div><p>The server may advertise a session ID that can be used to identify this process
across multiple requests. The client may advertise its own session ID back to
the server as well.</p><p>Session IDs should be unique to a given process. They must fit within a
packet-line, and must not contain non-printable or whitespace characters. The
current implementation uses trace2 session IDs (see
<a class="ulink" href="https://www.kernel.org/pub/software/scm/git/docs/technical/api-trace2.html" target="_blank"><em class="citetitle">api-trace2</em></a> for details), but this may change
and users of the session ID should not rely on this fact.</p></div><div class="section" title="object-info"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__object_info"></a>object-info</h2></div></div></div><p><span class="emphasis"><em>object-info</em></span> is the command to retrieve information about one or more objects.
Its main purpose is to allow a client to make decisions based on this
information without having to fully fetch objects. Object size is the only
information that is currently supported.</p><p>An <span class="emphasis"><em>object-info</em></span> request takes the following arguments:</p><pre class="literallayout">size
Requests size information to be returned for each listed object id.</pre><pre class="literallayout">oid &lt;oid&gt;
Indicates to the server an object which the client wants to obtain
information for.</pre><p>The response of <span class="emphasis"><em>object-info</em></span> is a list of the requested object ids
and associated requested information, each separated by a single space.</p><pre class="literallayout">output = info flush-pkt</pre><pre class="literallayout">info = PKT-LINE(attrs) LF)
        *PKT-LINE(obj-info LF)</pre><pre class="literallayout">attrs = attr | attrs SP attrs</pre><pre class="literallayout">attr = "size"</pre><pre class="literallayout">obj-info = obj-id SP obj-size</pre></div><div class="section" title="bundle-uri"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__bundle_uri"></a>bundle-uri</h2></div></div></div><p>If the <span class="emphasis"><em>bundle-uri</em></span> capability is advertised, the server supports the
bundle-uri command.</p><p>The capability is currently advertised with no value (i.e. not
"bundle-uri=somevalue"), a value may be added in the future for
supporting command-wide extensions. Clients MUST ignore any unknown
capability values and proceed with the 'bundle-uri` dialog they
support.</p><p>The <span class="emphasis"><em>bundle-uri</em></span> command is intended to be issued before <span class="emphasis"><em>fetch</em></span> to
get URIs to bundle files (see <a class="xref" href="git-command.html#git-bundle(1)" title="git-bundle(1)">the section called “git-bundle(1)”</a>) to "seed" and
inform the subsequent <span class="emphasis"><em>fetch</em></span> command.</p><p>The client CAN issue <span class="emphasis"><em>bundle-uri</em></span> before or after any other valid
command. To be useful to clients it's expected that it'll be issued
after an <span class="emphasis"><em>ls-refs</em></span> and before <span class="emphasis"><em>fetch</em></span>, but CAN be issued at any time
in the dialog.</p><div class="section" title="DISCUSSION of bundle-uri"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-v2(5)__discussion_of_bundle_uri"></a>DISCUSSION of bundle-uri</h3></div></div></div><p>The intent of the feature is optimize for server resource consumption
in the common case by changing the common case of fetching a very
large PACK during <a class="xref" href="git-command.html#git-clone(1)" title="git-clone(1)">the section called “git-clone(1)”</a> into a smaller incremental
fetch.</p><p>It also allows servers to achieve better caching in combination with
an <span class="emphasis"><em>uploadpack.packObjectsHook</em></span> (see <a class="xref" href="git-command.html#git-config(1)" title="git-config(1)">the section called “git-config(1)”</a>).</p><p>By having new clones or fetches be a more predictable and common
negotiation against the tips of recently produces *.bundle file(s).
Servers might even pre-generate the results of such negotiations for
the <span class="emphasis"><em>uploadpack.packObjectsHook</em></span> as new pushes come in.</p><p>One way that servers could take advantage of these bundles is that the
server would anticipate that fresh clones will download a known bundle,
followed by catching up to the current state of the repository using ref
tips found in that bundle (or bundles).</p></div><div class="section" title="PROTOCOL for bundle-uri"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-v2(5)__protocol_for_bundle_uri"></a>PROTOCOL for bundle-uri</h3></div></div></div><p>A <span class="emphasis"><em>bundle-uri</em></span> request takes no arguments, and as noted above does not
currently advertise a capability value. Both may be added in the
future.</p><p>When the client issues a <span class="emphasis"><em>command=bundle-uri</em></span> request, the response is a
list of key-value pairs provided as packet lines with value
<span class="emphasis"><em>&lt;key&gt;=&lt;value&gt;</em></span>. Each <span class="emphasis"><em>&lt;key&gt;</em></span> should be interpreted as a config key from
the <span class="emphasis"><em>bundle.*</em></span> namespace to construct a list of bundles. These keys are
grouped by a <span class="emphasis"><em>bundle.&lt;id&gt;.</em></span> subsection, where each key corresponding to a
given <span class="emphasis"><em>&lt;id&gt;</em></span> contributes attributes to the bundle defined by that <span class="emphasis"><em>&lt;id&gt;</em></span>.
See <a class="xref" href="git-command.html#git-config(1)" title="git-config(1)">the section called “git-config(1)”</a> for the specific details of these keys and how
the Git client will interpret their values.</p><p>Clients MUST parse the line according to the above format, lines that do
not conform to the format SHOULD be discarded. The user MAY be warned in
such a case.</p></div><div class="section" title="bundle-uri CLIENT AND SERVER EXPECTATIONS"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-v2(5)__bundle_uri_client_and_server_expectations"></a>bundle-uri CLIENT AND SERVER EXPECTATIONS</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">
URI CONTENTS
</span></dt><dd><p class="simpara">
The content at the advertised URIs MUST be one of two types.
</p><p class="simpara">The advertised URI may contain a bundle file that <span class="emphasis"><em>git bundle verify</em></span>
would accept. I.e. they MUST contain one or more reference tips for
use by the client, MUST indicate prerequisites (in any) with standard
"-" prefixes, and MUST indicate their "object-format", if
applicable.</p><p class="simpara">The advertised URI may alternatively contain a plaintext file that <span class="emphasis"><em>git
config --list</em></span> would accept (with the <span class="emphasis"><em>--file</em></span> option). The key-value
pairs in this list are in the <span class="emphasis"><em>bundle.*</em></span> namespace (see
<a class="xref" href="git-command.html#git-config(1)" title="git-config(1)">the section called “git-config(1)”</a>).</p></dd><dt><span class="term">
bundle-uri CLIENT ERROR RECOVERY
</span></dt><dd><p class="simpara">
A client MUST above all gracefully degrade on errors, whether that
error is because of bad missing/data in the bundle URI(s), because
that client is too dumb to e.g. understand and fully parse out bundle
headers and their prerequisite relationships, or something else.
</p><p class="simpara">Server operators should feel confident in turning on "bundle-uri" and
not worry if e.g. their CDN goes down that clones or fetches will run
into hard failures. Even if the server bundle(s) are
incomplete, or bad in some way the client should still end up with a
functioning repository, just as if it had chosen not to use this
protocol extension.</p><p class="simpara">All subsequent discussion on client and server interaction MUST keep
this in mind.</p></dd><dt><span class="term">
bundle-uri SERVER TO CLIENT
</span></dt><dd><p class="simpara">
The ordering of the returned bundle uris is not significant. Clients
MUST parse their headers to discover their contained OIDS and
prerequisites. A client MUST consider the content of the bundle(s)
themselves and their header as the ultimate source of truth.
</p><p class="simpara">A server MAY even return bundle(s) that don't have any direct
relationship to the repository being cloned (either through accident,
or intentional "clever" configuration), and expect a client to sort
out what data they'd like from the bundle(s), if any.</p></dd><dt><span class="term">
bundle-uri CLIENT TO SERVER
</span></dt><dd>
The client SHOULD provide reference tips found in the bundle header(s)
as <span class="emphasis"><em>have</em></span> lines in any subsequent <span class="emphasis"><em>fetch</em></span> request. A client MAY also
ignore the bundle(s) entirely if doing so is deemed worse for some
reason, e.g. if the bundles can't be downloaded, it doesn't like the
tips it finds etc.
</dd><dt><span class="term">
WHEN ADVERTISED BUNDLE(S) REQUIRE NO FURTHER NEGOTIATION
</span></dt><dd>
If after issuing <span class="emphasis"><em>bundle-uri</em></span> and <span class="emphasis"><em>ls-refs</em></span>, and getting the header(s)
of the bundle(s) the client finds that the ref tips it wants can be
retrieved entirely from advertised bundle(s), the client MAY disconnect
from the Git server. The results of such a <span class="emphasis"><em>clone</em></span> or <span class="emphasis"><em>fetch</em></span> should be
indistinguishable from the state attained without using bundle-uri.
</dd><dt><span class="term">
EARLY CLIENT DISCONNECTIONS AND ERROR RECOVERY
</span></dt><dd><p class="simpara">
A client MAY perform an early disconnect while still downloading the
bundle(s) (having streamed and parsed their headers). In such a case
the client MUST gracefully recover from any errors related to
finishing the download and validation of the bundle(s).
</p><p class="simpara">I.e. a client might need to re-connect and issue a <span class="emphasis"><em>fetch</em></span> command,
and possibly fall back to not making use of <span class="emphasis"><em>bundle-uri</em></span> at all.</p><p class="simpara">This "MAY" behavior is specified as such (and not a "SHOULD") on the
assumption that a server advertising bundle uris is more likely than
not to be serving up a relatively large repository, and to be pointing
to URIs that have a good chance of being in working order. A client
MAY e.g. look at the payload size of the bundles as a heuristic to see
if an early disconnect is worth it, should falling back on a full
"fetch" dialog be necessary.</p></dd><dt><span class="term">
WHEN ADVERTISED BUNDLE(S) REQUIRE FURTHER NEGOTIATION
</span></dt><dd><p class="simpara">
A client SHOULD commence a negotiation of a PACK from the server via
the "fetch" command using the OID tips found in advertised bundles,
even if's still in the process of downloading those bundle(s).
</p><p class="simpara">This allows for aggressive early disconnects from any interactive
server dialog. The client blindly trusts that the advertised OID tips
are relevant, and issues them as <span class="emphasis"><em>have</em></span> lines, it then requests any
tips it would like (usually from the "ls-refs" advertisement) via
<span class="emphasis"><em>want</em></span> lines. The server will then compute a (hopefully small) PACK
with the expected difference between the tips from the bundle(s) and
the data requested.</p><p class="simpara">The only connection the client then needs to keep active is to the
concurrently downloading static bundle(s), when those and the
incremental PACK are retrieved they should be inflated and
validated. Any errors at this point should be gracefully recovered
from, see above.</p></dd></dl></div></div><div class="section" title="bundle-uri PROTOCOL FEATURES"><div class="titlepage"><div><div><h3 class="title"><a name="gitprotocol-v2(5)__bundle_uri_protocol_features"></a>bundle-uri PROTOCOL FEATURES</h3></div></div></div><p>The client constructs a bundle list from the <span class="emphasis"><em>&lt;key&gt;=&lt;value&gt;</em></span> pairs
provided by the server. These pairs are part of the <span class="emphasis"><em>bundle.*</em></span> namespace
as documented in <a class="xref" href="git-command.html#git-config(1)" title="git-config(1)">the section called “git-config(1)”</a>. In this section, we discuss some
of these keys and describe the actions the client will do in response to
this information.</p><p>In particular, the <span class="emphasis"><em>bundle.version</em></span> key specifies an integer value. The
only accepted value at the moment is <span class="emphasis"><em>1</em></span>, but if the client sees an
unexpected value here then the client MUST ignore the bundle list.</p><p>As long as <span class="emphasis"><em>bundle.version</em></span> is understood, all other unknown keys MAY be
ignored by the client. The server will guarantee compatibility with older
clients, though newer clients may be better able to use the extra keys to
minimize downloads.</p><p>Any backwards-incompatible addition of pre-URI key-value will be
guarded by a new <span class="emphasis"><em>bundle.version</em></span> value or values in <span class="emphasis"><em>bundle-uri</em></span>
capability advertisement itself, and/or by new future <span class="emphasis"><em>bundle-uri</em></span>
request arguments.</p><p>Some example key-value pairs that are not currently implemented but could
be implemented in the future include:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Add a "hash=&lt;val&gt;" or "size=&lt;bytes&gt;" advertise the expected hash or
   size of the bundle file.
</li><li class="listitem">
Advertise that one or more bundle files are the same (to e.g. have
   clients round-robin or otherwise choose one of N possible files).
</li><li class="listitem"><p class="simpara">
A "oid=&lt;OID&gt;" shortcut and "prerequisite=&lt;OID&gt;" shortcut. For
   expressing the common case of a bundle with one tip and no
   prerequisites, or one tip and one prerequisite.
</p><p class="simpara">This would allow for optimizing the common case of servers who'd like
to provide one "big bundle" containing only their "main" branch,
and/or incremental updates thereof.</p><p class="simpara">A client receiving such a response MAY assume that they can skip
retrieving the header from a bundle at the indicated URI, and thus
save themselves and the server(s) the request(s) needed to inspect the
headers of that bundle or bundles.</p></li></ul></div></div></div><div class="section" title="promisor-remote=&lt;pr-infos&gt;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gitprotocol-v2(5)__promisor_remote_lt_pr_infos_gt"></a>promisor-remote=&lt;pr-infos&gt;</h2></div></div></div><p>The server may advertise some promisor remotes it is using or knows
about to a client which may want to use them as its promisor remotes,
instead of this repository. In this case &lt;pr-infos&gt; should be of the
form:</p><pre class="literallayout">pr-infos = pr-info | pr-infos ";" pr-info</pre><pre class="literallayout">pr-info = "name=" pr-name | "name=" pr-name "," "url=" pr-url</pre><p>where <span class="emphasis"><em>pr-name</em></span> is the urlencoded name of a promisor remote, and
<span class="emphasis"><em>pr-url</em></span> the urlencoded URL of that promisor remote.</p><p>In this case, if the client decides to use one or more promisor
remotes the server advertised, it can reply with
"promisor-remote=&lt;pr-names&gt;" where &lt;pr-names&gt; should be of the form:</p><pre class="literallayout">pr-names = pr-name | pr-names ";" pr-name</pre><p>where <span class="emphasis"><em>pr-name</em></span> is the urlencoded name of a promisor remote the server
advertised and the client accepts.</p><p>Note that, everywhere in this document, <span class="emphasis"><em>pr-name</em></span> MUST be a valid
remote name, and the <span class="emphasis"><em>;</em></span> and <span class="emphasis"><em>,</em></span> characters MUST be encoded if they
appear in <span class="emphasis"><em>pr-name</em></span> or <span class="emphasis"><em>pr-url</em></span>.</p><p>If the server doesn't know any promisor remote that could be good for
a client to use, or prefers a client not to use any promisor remote it
uses or knows about, it shouldn't advertise the "promisor-remote"
capability at all.</p><p>In this case, or if the client doesn't want to use any promisor remote
the server advertised, the client shouldn't advertise the
"promisor-remote" capability at all in its reply.</p><p>The "promisor.advertise" and "promisor.acceptFromServer" configuration
options can be used on the server and client side to control what they
advertise or accept respectively. See the documentation of these
configuration options for more information.</p><p>Note that in the future it would be nice if the "promisor-remote"
protocol capability could be used by the server, when responding to
<span class="emphasis"><em>git fetch</em></span> or <span class="emphasis"><em>git clone</em></span>, to advertise better-connected remotes that
the client can use as promisor remotes, instead of this repository, so
that the client can lazily fetch objects from these other
better-connected remotes. This would require the server to omit in its
response the objects available on the better-connected remotes that
the client has accepted. This hasn't been implemented yet though. So
for now this "promisor-remote" capability is useful only when the
server advertises some promisor remotes it already uses to borrow
objects from.</p></div></div><div class="simplesect" title="GIT"><div class="titlepage"><div><div><h4 class="title"><a name="gitprotocol-v2(5)__git"></a>GIT</h4></div></div></div><p>Part of the <a class="xref" href="git-command.html#git(1)" title="git(1)">the section called “git(1)”</a> suite</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="git-misc.html#gitworkflows(7)__patch_workflow">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="apg.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="git-developerinfo.html#gitformat-commit-graph(5)__chunk_lookup">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Patch workflow </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> CHUNK LOOKUP:</td></tr></table></div></body></html>
